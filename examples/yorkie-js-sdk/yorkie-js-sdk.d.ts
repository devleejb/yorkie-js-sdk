import * as jspb from 'google-protobuf';
import { default as Long_2 } from 'long';
/**
 * `ActorID` is used to identify who is making changes to the document.
 * It is a hexadecimal string and should be generated by a unique value.
 *
 * @public
 */
export declare type ActorID = string;
export declare type AddOpInfo = {
    type: 'add';
    path: string;
    index: number;
};
/**
 * @internal
 */
declare interface BaseClientEvent {
    type: ClientEventType;
}
/**
 * @internal
 */
declare interface BaseDocEvent {
    type: DocEventType;
}
/**
 * `bytesToObject` creates an JSONObject from the given byte array.
 */
declare function bytesToObject(bytes?: Uint8Array): CRDTObject;
/**
 * `Change` represents a unit of modification in the document.
 */
export declare class Change {
    private id;
    private operations;
    private message?;
    constructor(id: ChangeID, operations: Array<Operation>, message?: string);
    /**
     * `create` creates a new instance of Change.
     */
    static create(id: ChangeID, operations: Array<Operation>, message?: string): Change;
    /**
     * `getID` returns the ID of this change.
     */
    getID(): ChangeID;
    /**
     * `getMessage` returns the message of this change.
     */
    getMessage(): string | undefined;
    /**
     * `getOperations` returns the operations of this change.
     */
    getOperations(): Array<Operation>;
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID: ActorID): void;
    /**
     * `execute` executes the operations of this change to the given root.
     */
    execute(root: CRDTRoot): Array<InternalOpInfo>;
    /**
     * `getStructureAsString` returns a string containing the meta data of this change.
     */
    getStructureAsString(): string;
}
declare class Change_2 {
    getId(): ChangeID_2 | undefined;
    setId(value?: ChangeID_2): Change_2;
    hasId(): boolean;
    clearId(): Change_2;
    getMessage(): string;
    setMessage(value: string): Change_2;
    getOperationsList(): Array<Operation_2>;
    setOperationsList(value: Array<Operation_2>): Change_2;
    clearOperationsList(): Change_2;
    addOperations(value?: Operation_2, index?: number): Operation_2;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Change_2.AsObject;
    static toObject(includeInstance: boolean, msg: Change_2): Change_2.AsObject;
    static serializeBinaryToWriter(message: Change_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Change_2;
    static deserializeBinaryFromReader(message: Change_2, reader: jspb.BinaryReader): Change_2;
}
declare namespace Change_2 {
    type AsObject = {
        id?: ChangeID_2.AsObject;
        message: string;
        operationsList: Array<Operation_2.AsObject>;
    };
}
/**
 * `ChangeContext` is used to record the context of modification when editing
 * a document. Each time we add an operation, a new time ticket is issued.
 * Finally returns a Change after the modification has been completed.
 */
declare class ChangeContext {
    private id;
    private root;
    private operations;
    private message?;
    private delimiter;
    constructor(id: ChangeID, root: CRDTRoot, message?: string);
    /**
     * `create` creates a new instance of ChangeContext.
     */
    static create(id: ChangeID, root: CRDTRoot, message?: string): ChangeContext;
    /**
     * `push` pushes the given operation to this context.
     */
    push(operation: Operation): void;
    /**
     * `registerElement` registers the given element to the root.
     */
    registerElement(element: Primitive, parent: CRDTContainer): void;
    /**
     * `registerRemovedElement` register removed element for garbage collection.
     */
    registerRemovedElement(deleted: Primitive): void;
    /**
     * `registerRemovedNodeTextElement` register text element has removed node for
     * garbage collection.
     */
    registerRemovedNodeTextElement(text: CRDTTextElement): void;
    /**
     * `getChange` creates a new instance of Change in this context.
     */
    getChange(): Change;
    /**
     * `hasOperations` returns the whether this context has operations or not.
     */
    hasOperations(): boolean;
    /**
     * `issueTimeTicket` creates a time ticket to be used to create a new operation.
     */
    issueTimeTicket(): TimeTicket;
    /**
     * `getLastTimeTicket` returns the last time ticket issued in this context.
     */
    getLastTimeTicket(): TimeTicket;
}
/**
 * `ChangeID` is for identifying the Change. This is immutable.
 */
declare class ChangeID {
    private clientSeq;
    private serverSeq?;
    private lamport;
    private actor?;
    constructor(clientSeq: number, lamport: Long_2, actor?: ActorID);
    /**
     * `of` creates a new instance of ChangeID.
     */
    static of(clientSeq: number, lamport: Long_2, actor?: ActorID): ChangeID;
    /**
     * `next` creates a next ID of this ID.
     */
    next(): ChangeID;
    /**
     * `syncLamport` syncs lamport timestamp with the given ID.
     *
     * {@link https://en.wikipedia.org/wiki/Lamport_timestamps#Algorithm}
     */
    syncLamport(otherLamport: Long_2): ChangeID;
    /**
     * `createTimeTicket` creates a ticket of the given delimiter.
     */
    createTimeTicket(delimiter: number): TimeTicket;
    /**
     * `setActor` sets the given actor.
     */
    setActor(actorID: ActorID): ChangeID;
    /**
     * `getClientSeq` returns the client sequence of this ID.
     */
    getClientSeq(): number;
    /**
     * `getLamport` returns the lamport clock of this ID.
     */
    getLamport(): Long_2;
    /**
     * `getLamportAsString` returns the lamport clock of this ID as a string.
     */
    getLamportAsString(): string;
    /**
     * `getActorID` returns the actor of this ID.
     */
    getActorID(): string | undefined;
    /**
     * `getStructureAsString` returns a string containing the meta data of this ID.
     */
    getStructureAsString(): string;
}
declare class ChangeID_2 {
    getClientSeq(): number;
    setClientSeq(value: number): ChangeID_2;
    getServerSeq(): string;
    setServerSeq(value: string): ChangeID_2;
    getLamport(): string;
    setLamport(value: string): ChangeID_2;
    getActorId(): Uint8Array | string;
    getActorId_asU8(): Uint8Array;
    getActorId_asB64(): string;
    setActorId(value: Uint8Array | string): ChangeID_2;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ChangeID_2.AsObject;
    static toObject(includeInstance: boolean, msg: ChangeID_2): ChangeID_2.AsObject;
    static serializeBinaryToWriter(message: ChangeID_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ChangeID_2;
    static deserializeBinaryFromReader(message: ChangeID_2, reader: jspb.BinaryReader): ChangeID_2;
}
declare namespace ChangeID_2 {
    type AsObject = {
        clientSeq: number;
        serverSeq: string;
        lamport: string;
        actorId: Uint8Array | string;
    };
}
/**
 * `ChangeInfo` represents the modifications made during a document update
 * and the message passed.
 */
export declare interface ChangeInfo {
    message: string;
    operations: Array<OperationInfo>;
    actor: ActorID | undefined;
}
/**
 * `ChangePack` is a unit for delivering changes in a document to the remote.
 *
 * @internal
 */
declare class ChangePack {
    /**
     * `documentKey` is the key of the document.
     */
    private documentKey;
    /**
     * `Checkpoint` is used to determine the client received changes.
     */
    private checkpoint;
    /**
     * `isRemoved` is a flag that indicates whether the document is removed.
     */
    private isRemoved;
    private changes;
    /**
     * `snapshot` is a byte array that encodes the document.
     */
    private snapshot?;
    /**
     * `minSyncedTicket` is the minimum logical time taken by clients who attach
     * to the document. It is used to collect garbage on the replica on the
     * client.
     */
    private minSyncedTicket?;
    constructor(key: string, checkpoint: Checkpoint, isRemoved: boolean, changes: Array<Change>, snapshot?: Uint8Array, minSyncedTicket?: TimeTicket);
    /**
     * `create` creates a new instance of ChangePack.
     */
    static create(key: string, checkpoint: Checkpoint, isRemoved: boolean, changes: Array<Change>, snapshot?: Uint8Array, minSyncedTicket?: TimeTicket): ChangePack;
    /**
     * `getKey` returns the document key of this pack.
     */
    getDocumentKey(): string;
    /**
     * `getCheckpoint` returns the checkpoint of this pack.
     */
    getCheckpoint(): Checkpoint;
    /**
     * `getIsRemoved` returns the whether this document is removed.
     */
    getIsRemoved(): boolean;
    /**
     * `getChanges` returns the changes of this pack.
     */
    getChanges(): Array<Change>;
    /**
     * `hasChanges` returns the whether this pack has changes or not.
     */
    hasChanges(): boolean;
    /**
     * `getChangeSize` returns the size of changes this pack has.
     */
    getChangeSize(): number;
    /**
     * `hasSnapshot` returns the whether this pack has a snapshot or not.
     */
    hasSnapshot(): boolean;
    /**
     * `getSnapshot` returns the snapshot of this pack.
     */
    getSnapshot(): Uint8Array | undefined;
    /**
     * `getMinSyncedTicket` returns the minimum synced ticket of this pack.
     */
    getMinSyncedTicket(): TimeTicket | undefined;
}
declare class ChangePack_2 {
    getDocumentKey(): string;
    setDocumentKey(value: string): ChangePack_2;
    getCheckpoint(): Checkpoint_2 | undefined;
    setCheckpoint(value?: Checkpoint_2): ChangePack_2;
    hasCheckpoint(): boolean;
    clearCheckpoint(): ChangePack_2;
    getSnapshot(): Uint8Array | string;
    getSnapshot_asU8(): Uint8Array;
    getSnapshot_asB64(): string;
    setSnapshot(value: Uint8Array | string): ChangePack_2;
    getChangesList(): Array<Change_2>;
    setChangesList(value: Array<Change_2>): ChangePack_2;
    clearChangesList(): ChangePack_2;
    addChanges(value?: Change_2, index?: number): Change_2;
    getMinSyncedTicket(): TimeTicket_2 | undefined;
    setMinSyncedTicket(value?: TimeTicket_2): ChangePack_2;
    hasMinSyncedTicket(): boolean;
    clearMinSyncedTicket(): ChangePack_2;
    getIsRemoved(): boolean;
    setIsRemoved(value: boolean): ChangePack_2;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ChangePack_2.AsObject;
    static toObject(includeInstance: boolean, msg: ChangePack_2): ChangePack_2.AsObject;
    static serializeBinaryToWriter(message: ChangePack_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ChangePack_2;
    static deserializeBinaryFromReader(message: ChangePack_2, reader: jspb.BinaryReader): ChangePack_2;
}
declare namespace ChangePack_2 {
    type AsObject = {
        documentKey: string;
        checkpoint?: Checkpoint_2.AsObject;
        snapshot: Uint8Array | string;
        changesList: Array<Change_2.AsObject>;
        minSyncedTicket?: TimeTicket_2.AsObject;
        isRemoved: boolean;
    };
}
/**
 * `Checkpoint` is used to determine the changes sent and received by the
 * client. This is immutable.
 *
 * @internal
 **/
declare class Checkpoint {
    private serverSeq;
    private clientSeq;
    constructor(serverSeq: Long_2, clientSeq: number);
    /**
     * `of` creates a new instance of Checkpoint.
     */
    static of(serverSeq: Long_2, clientSeq: number): Checkpoint;
    /**
     * `increaseClientSeq` creates a new instance with increased client sequence.
     */
    increaseClientSeq(inc: number): Checkpoint;
    /**
     * `forward` creates a new instance with the given checkpoint if it is
     * greater than the values of internal properties.
     */
    forward(other: Checkpoint): Checkpoint;
    /**
     * `getServerSeqAsString` returns the server seq of this checkpoint as a
     * string.
     */
    getServerSeqAsString(): string;
    /**
     * `getClientSeq` returns the client seq of this checkpoint.
     */
    getClientSeq(): number;
    /**
     * `getServerSeq` returns the server seq of this checkpoint.
     */
    getServerSeq(): Long_2;
    /**
     * `equals` returns whether the given checkpoint is equal to this checkpoint
     * or not.
     */
    equals(other: Checkpoint): boolean;
    /**
     * `getStructureAsString` returns a string containing the meta data of this
     * checkpoint.
     */
    getStructureAsString(): string;
}
declare class Checkpoint_2 {
    getServerSeq(): string;
    setServerSeq(value: string): Checkpoint_2;
    getClientSeq(): number;
    setClientSeq(value: number): Checkpoint_2;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Checkpoint_2.AsObject;
    static toObject(includeInstance: boolean, msg: Checkpoint_2): Checkpoint_2.AsObject;
    static serializeBinaryToWriter(message: Checkpoint_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Checkpoint_2;
    static deserializeBinaryFromReader(message: Checkpoint_2, reader: jspb.BinaryReader): Checkpoint_2;
}
declare namespace Checkpoint_2 {
    type AsObject = {
        serverSeq: string;
        clientSeq: number;
    };
}
/**
 * `Client` is a normal client that can communicate with the server.
 * It has documents and sends changes of the documents in local
 * to the server to synchronize with other replicas in remote.
 *
 * @public
 */
export declare class Client<P = Indexable> implements Observable<ClientEvent<P>> {
    private id?;
    private key;
    private presenceInfo;
    private status;
    private attachmentMap;
    private apiKey;
    private syncLoopDuration;
    private reconnectStreamDelay;
    private retrySyncLoopDelay;
    private rpcClient;
    private eventStream;
    private eventStreamObserver;
    /**
     * @param rpcAddr - the address of the RPC server.
     * @param opts - the options of the client.
     */
    constructor(rpcAddr: string, opts?: ClientOptions<P>);
    /**
     * `ativate` activates this client. That is, it registers itself to the server
     * and receives a unique ID from the server. The given ID is used to
     * distinguish different clients.
     */
    activate(): Promise<void>;
    /**
     * `deactivate` deactivates this client.
     */
    deactivate(): Promise<void>;
    /**
     * `attach` attaches the given document to this client. It tells the server that
     * this client will synchronize the given document.
     */
    attach(doc: Document_2<unknown>, isManualSync?: boolean): Promise<Document_2<unknown>>;
    /**
     * `detach` detaches the given document from this client. It tells the
     * server that this client will no longer synchronize the given document.
     *
     * To collect garbage things like CRDT tombstones left on the document, all
     * the changes should be applied to other replicas before GC time. For this,
     * if the document is no longer used by this client, it should be detached.
     */
    detach(doc: Document_2<unknown>): Promise<Document_2<unknown>>;
    /**
     * `pause` changes the synchronization mode of the given document to manual.
     */
    pause(doc: Document_2<unknown>): Promise<Document_2<unknown>>;
    /**
     * `resume` changes the synchronization mode of the given document to realtime.
     */
    resume(doc: Document_2<unknown>): Promise<Document_2<unknown>>;
    /**
     * `pauseRemoteChanges` pauses the synchronization of remote changes,
     * allowing only local changes to be applied.
     */
    pauseRemoteChanges(doc: Document_2<unknown>): void;
    /**
     * `resumeRemoteChanges` resumes the synchronization of remote changes,
     * allowing both local and remote changes to be applied.
     */
    resumeRemoteChanges(doc: Document_2<unknown>): void;
    /**
     * `changeRealtimeSync` changes the synchronization mode of the given document.
     */
    private changeRealtimeSync;
    /**
     * `sync` pushes local changes of the attached documents to the server and
     * receives changes of the remote replica from the server then apply them to
     * local documents.
     */
    sync(doc?: Document_2<unknown>, syncMode?: SyncMode): Promise<Array<Document_2<unknown>>>;
    /**
     * `remove` removes the given document.
     */
    remove(doc: Document_2<unknown>): Promise<void>;
    /**
     * `updatePresence` updates the presence of this client.
     */
    updatePresence<K extends keyof P>(key: K, value: P[K]): Promise<void>;
    /**
     * `subscribe` subscribes to the given topics.
     */
    subscribe(nextOrObserver: Observer<ClientEvent<P>> | NextFn<ClientEvent<P>>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `getID` returns a ActorID of client.
     */
    getID(): string | undefined;
    /**
     * `getKey` returns a key of client.
     */
    getKey(): string;
    /**
     * `isActive` checks if the client is active.
     */
    isActive(): boolean;
    /**
     * `getStatus` returns the status of this client.
     */
    getStatus(): ClientStatus;
    /**
     * `getPresence` returns the presence of this client.
     */
    getPresence(): P;
    /**
     * `getPeerPresence` returns the presence of the given document and client.
     */
    getPeerPresence(docKey: DocumentKey, clientID: ActorID): P | undefined;
    /**
     * `getPeersByDocKey` returns the peers of the given document.
     */
    getPeersByDocKey(docKey: DocumentKey): Array<{
        clientID: ActorID;
        presence: P;
    }>;
    private runSyncLoop;
    private runWatchLoop;
    private handleWatchDocumentsResponse;
    private detachInternal;
    private syncInternal;
}
declare class Client_2 {
    getId(): Uint8Array | string;
    getId_asU8(): Uint8Array;
    getId_asB64(): string;
    setId(value: Uint8Array | string): Client_2;
    getPresence(): Presence | undefined;
    setPresence(value?: Presence): Client_2;
    hasPresence(): boolean;
    clearPresence(): Client_2;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Client_2.AsObject;
    static toObject(includeInstance: boolean, msg: Client_2): Client_2.AsObject;
    static serializeBinaryToWriter(message: Client_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Client_2;
    static deserializeBinaryFromReader(message: Client_2, reader: jspb.BinaryReader): Client_2;
}
declare namespace Client_2 {
    type AsObject = {
        id: Uint8Array | string;
        presence?: Presence.AsObject;
    };
}
/**
 * `ClientEvent` is an event that occurs in `Client`. It can be delivered using
 * `Client.subscribe()`.
 *
 * @public
 */
export declare type ClientEvent<P = Indexable> = StatusChangedEvent | DocumentsChangedEvent | PeersChangedEvent<P> | StreamConnectionStatusChangedEvent | DocumentSyncedEvent;
/**
 * `ClientEventType` represents the type of the event that the client can emit.
 * @public
 */
export declare enum ClientEventType {
    /**
     * `StatusChanged` means that the status of the client has changed.
     */
    StatusChanged = "status-changed",
    /**
     * `DocumentsChanged` means that the documents of the client has changed.
     */
    DocumentsChanged = "documents-changed",
    /**
     * `PeersChanged` means that the presences of the peer clients has changed.
     */
    PeersChanged = "peers-changed",
    /**
     * `StreamConnectionStatusChanged` means that the stream connection status of
     * the client has changed.
     */
    StreamConnectionStatusChanged = "stream-connection-status-changed",
    /**
     * `DocumentSynced` means that the document has been synced with the server.
     */
    DocumentSynced = "document-synced"
}
/**
 * `ClientOptions` are user-settable options used when defining clients.
 *
 * @public
 */
export declare interface ClientOptions<P> {
    /**
     * `key` is the client key. It is used to identify the client.
     * If not set, a random key is generated.
     */
    key?: string;
    /**
     * `presence` is the presence information of this client. If the client
     * attaches a document, the presence information is sent to the other peers
     * attached to the document.
     */
    presence?: P;
    /**
     * `apiKey` is the API key of the project. It is used to identify the project.
     * If not set, API key of the default project is used.
     */
    apiKey?: string;
    /**
     * `token` is the authentication token of this client. It is used to identify
     * the user of the client.
     */
    token?: string;
    /**
     * `syncLoopDuration` is the duration of the sync loop. After each sync loop,
     * the client waits for the duration to next sync. The default value is
     * `50`(ms).
     */
    syncLoopDuration?: number;
    /**
     * `retrySyncLoopDelay` is the delay of the retry sync loop. If the sync loop
     * fails, the client waits for the delay to retry the sync loop. The default
     * value is `1000`(ms).
     */
    retrySyncLoopDelay?: number;
    /**
     * `reconnectStreamDelay` is the delay of the reconnect stream. If the stream
     * is disconnected, the client waits for the delay to reconnect the stream. The
     * default value is `1000`(ms).
     */
    reconnectStreamDelay?: number;
}
/**
 * `ClientStatus` represents the status of the client.
 * @public
 */
export declare enum ClientStatus {
    /**
     * `Deactivated` means that the client is not activated. It is the initial
     * status of the client. If the client is deactivated, all `Document`s of the
     * client are also not used.
     */
    Deactivated = "deactivated",
    /**
     * `Activated` means that the client is activated. If the client is activated,
     * all `Document`s of the client are also ready to be used.
     */
    Activated = "activated"
}
declare type Comparator<K> = (keyA: K, keyB: K) => number;
/**
 * @internal
 */
export declare type CompleteFn = () => void;
/**
 * `converter` is a converter that converts the given model to protobuf format.
 * is also used to convert models to bytes and vice versa.
 */
export declare const converter: {
    fromPresence: typeof fromPresence;
    toClient: typeof toClient;
    toChangePack: typeof toChangePack;
    fromChangePack: typeof fromChangePack;
    fromChanges: typeof fromChanges;
    objectToBytes: typeof objectToBytes;
    bytesToObject: typeof bytesToObject;
    toHexString: typeof toHexString;
    toUint8Array: typeof toUint8Array;
};
/**
 * `Counter` is a custom data type that is used to counter.
 */
export declare class Counter {
    private valueType;
    private value;
    private context?;
    private counter?;
    constructor(valueType: CounterType, value: number | Long_2);
    /**
     * `initialize` initialize this text with context and internal text.
     * @internal
     */
    initialize(context: ChangeContext, counter: CRDTCounter): void;
    /**
     * `getID` returns the ID of this text.
     */
    getID(): TimeTicket;
    /**
     * `getValue` returns the value of this counter;
     * @internal
     */
    getValue(): number | Long_2;
    /**
     * `getValueType` returns the value type of this counter.
     */
    getValueType(): CounterType;
    /**
     * `increase` increases numeric data.
     */
    increase(v: number | Long_2): Counter;
}
/**
 * @internal
 */
declare enum CounterType {
    IntegerCnt = 0,
    LongCnt = 1
}
declare type CounterValue = number | Long_2;
/**
 *
 * `CRDTContainer` represents CRDTArray or CRDtObject.
 * @internal
 */
declare abstract class CRDTContainer {
    constructor(createdAt: TimeTicket);
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    abstract subPathOf(createdAt: TimeTicket): string | undefined;
    abstract purge(element: Primitive): void;
    abstract delete(createdAt: TimeTicket, executedAt: TimeTicket): Primitive;
    abstract getDescendants(callback: (elem: Primitive, parent: CRDTContainer) => boolean): void;
}
/**
 * `CRDTCounter` is a CRDT implementation of a counter. It is used to represent
 * a number that can be incremented or decremented.
 *
 * @internal
 */
declare class CRDTCounter {
    private valueType;
    private value;
    constructor(valueType: CounterType, value: CounterValue, createdAt: TimeTicket);
    /**
     * `of` creates a new instance of Counter.
     */
    static create(valueType: CounterType, value: CounterValue, createdAt: TimeTicket): CRDTCounter;
    /**
     * `valueFromBytes` parses the given bytes into value.
     */
    static valueFromBytes(counterType: CounterType, bytes: Uint8Array): CounterValue;
    /**
     * `toJSON` returns the JSON encoding of the value.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of the value.
     */
    toSortedJSON(): string;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTCounter;
    /**
     * `getType` returns the type of the value.
     */
    getType(): CounterType;
    /**
     * `getCounterType` returns counter type of given value.
     */
    static getCounterType(value: CounterValue): CounterType | undefined;
    /**
     * `isSupport` check if there is a counter type of given value.
     */
    static isSupport(value: CounterValue): boolean;
    /**
     * `isInteger` checks if the num is integer.
     */
    static isInteger(num: number): boolean;
    /**
     * `isNumericType` check numeric type by JSONCounter.
     */
    isNumericType(): boolean;
    /**
     * `getValueType` get counter value type.
     */
    getValueType(): CounterType;
    /**
     * `getValue` get counter value.
     */
    getValue(): CounterValue;
    /**
     * `toBytes` creates an array representing the value.
     */
    toBytes(): Uint8Array;
    /**
     * `increase` increases numeric data.
     */
    increase(v: Primitive): CRDTCounter;
}
/**
 * `CRDTElement` represents an element that has `TimeTicket`s.
 *
 * @internal
 */
declare abstract class CRDTElement {
    private createdAt;
    private movedAt?;
    private removedAt?;
    constructor(createdAt: TimeTicket);
    /**
     * `getCreatedAt` returns the creation time of this element.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getID` returns the creation time of this element.
     */
    getID(): TimeTicket;
    /**
     * `getMovedAt` returns the move time of this element.
     */
    getMovedAt(): TimeTicket | undefined;
    /**
     * `getRemovedAt` returns the removal time of this element.
     */
    getRemovedAt(): TimeTicket | undefined;
    /**
     * `setMovedAt` sets the move time of this element.
     */
    setMovedAt(movedAt?: TimeTicket): boolean;
    /**
     * `setRemovedAt` sets the remove time of this element.
     */
    setRemovedAt(removedAt?: TimeTicket): void;
    /**
     * `remove` removes this element.
     */
    remove(removedAt?: TimeTicket): boolean;
    /**
     * `isRemoved` check if this element was removed.
     */
    isRemoved(): boolean;
    abstract toJSON(): string;
    abstract toSortedJSON(): string;
    abstract deepcopy(): Primitive;
}
/**
 * `CRDTObject` represents an object data type, but unlike regular JSON,
 * it has `TimeTicket`s which are created by logical clock.
 *
 * @internal
 */
declare class CRDTObject {
    private memberNodes;
    private constructor();
    /**
     * `create` creates a new instance of CRDTObject.
     */
    static create(createdAt: TimeTicket): CRDTObject;
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purges the given element.
     */
    purge(value: Primitive): void;
    /**
     * `set` sets the given element of the given key.
     */
    set(key: string, value: Primitive): Primitive | undefined;
    /**
     * `delete` deletes the element of the given key.
     */
    delete(createdAt: TimeTicket, executedAt: TimeTicket): Primitive;
    /**
     * `deleteByKey` deletes the element of the given key and execution time.
     */
    deleteByKey(key: string, executedAt: TimeTicket): Primitive | undefined;
    /**
     * `get` returns the value of the given key.
     */
    get(key: string): Primitive | undefined;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `toJSON` returns the JSON encoding of this object.
     */
    toJSON(): string;
    /**
     * `toJS` returns the JavaScript object of this object.
     */
    toJS(): any;
    /**
     * `getKeys` returns array of keys in this object.
     */
    getKeys(): Array<string>;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this object.
     */
    toSortedJSON(): string;
    /**
     * `getRHT` RHTNodes returns the RHTPQMap nodes.
     */
    getRHT(): ElementRHT;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTObject;
    /**
     * `getDescendants` returns the descendants of this object by traversing.
     */
    getDescendants(callback: (elem: Primitive, parent: CRDTContainer) => boolean): void;
    /**
     * eslint-disable-next-line jsdoc/require-jsdoc
     * @internal
     */
    [Symbol.iterator](): IterableIterator<[
        string,
        Primitive
    ]>;
}
/**
 * `CRDTRoot` is a structure that represents the root. It has a hash table of
 * all elements to find a specific element when applying remote changes
 * received from server.
 *
 * Every element has a unique `TimeTicket` at creation, which allows us to find
 * a particular element.
 */
declare class CRDTRoot {
    private rootObject;
    private elementPairMapByCreatedAt;
    private removedElementSetByCreatedAt;
    private textWithGarbageSetByCreatedAt;
    constructor(rootObject: CRDTObject);
    /**
     * `create` creates a new instance of Root.
     */
    static create(): CRDTRoot;
    /**
     * `findByCreatedAt` returns the element of given creation time.
     */
    findByCreatedAt(createdAt: TimeTicket): Primitive | undefined;
    /**
     * `createSubPaths` creates an array of the sub paths for the given element.
     */
    createSubPaths(createdAt: TimeTicket): Array<string>;
    /**
     * `createPath` creates path of the given element.
     */
    createPath(createdAt: TimeTicket): string;
    /**
     * `registerElement` registers the given element to hash table.
     */
    registerElement(element: Primitive, parent: CRDTContainer): void;
    /**
     * `deregisterElement` deregister the given element from hash table.
     */
    deregisterElement(element: Primitive): void;
    /**
     * `registerRemovedElement` registers the given element to the hash set.
     */
    registerRemovedElement(element: Primitive): void;
    /**
     * `registerTextWithGarbage` registers the given text to hash set.
     */
    registerTextWithGarbage(text: CRDTTextElement): void;
    /**
     * `getElementMapSize` returns the size of element map.
     */
    getElementMapSize(): number;
    /**
     * `getRemovedElementSetSize()` returns the size of removed element set.
     */
    getRemovedElementSetSize(): number;
    /**
     * `getObject` returns root object.
     */
    getObject(): CRDTObject;
    /**
     * `getGarbageLen` returns length of nodes which can be garbage collected.
     */
    getGarbageLen(): number;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTRoot;
    /**
     * `garbageCollect` purges elements that were removed before the given time.
     */
    garbageCollect(ticket: TimeTicket): number;
    private garbageCollectInternal;
    /**
     * `toJSON` returns the JSON encoding of this root object.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this root object.
     */
    toSortedJSON(): string;
}
/**
 *  `CRDTText` is a custom CRDT data type to represent the contents of text editors.
 *
 * @internal
 */
declare class CRDTText<A extends Indexable = Indexable> {
    private rgaTreeSplit;
    private selectionMap;
    constructor(rgaTreeSplit: RGATreeSplit<CRDTTextValue>, createdAt: TimeTicket);
    /**
     * `create` a instance of Text.
     */
    static create<A extends Indexable>(rgaTreeSplit: RGATreeSplit<CRDTTextValue>, createdAt: TimeTicket): CRDTText<A>;
    /**
     * `edit` edits the given range with the given value and attributes.
     *
     * @internal
     */
    edit(range: RGATreeSplitNodeRange, content: string, editedAt: TimeTicket, attributes?: Record<string, string>, latestCreatedAtMapByActor?: Map<string, TimeTicket>): [
        Map<string, TimeTicket>,
        Array<TextChange<A>>
    ];
    /**
     * `setStyle` applies the style of the given range.
     * 01. split nodes with from and to
     * 02. style nodes between from and to
     *
     * @param range - range of RGATreeSplitNode
     * @param attributes - style attributes
     * @param editedAt - edited time
     * @internal
     */
    setStyle(range: RGATreeSplitNodeRange, attributes: Record<string, string>, editedAt: TimeTicket): Array<TextChange<A>>;
    /**
     * `select` stores that the given range has been selected.
     *
     * @internal
     */
    select(range: RGATreeSplitNodeRange, updatedAt: TimeTicket): TextChange<A> | undefined;
    /**
     * `createRange` returns pair of RGATreeSplitNodePos of the given integer offsets.
     */
    createRange(fromIdx: number, toIdx: number): RGATreeSplitNodeRange;
    /**
     * `length` returns size of RGATreeList.
     */
    get length(): number;
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight(): boolean;
    /**
     * `toJSON` returns the JSON encoding of this text.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this text.
     */
    toSortedJSON(): string;
    /**
     * `toString` returns the string representation of this text.
     */
    toString(): string;
    /**
     * `values` returns the content-attributes pair array of this text.
     */
    values(): Array<TextValueType<A>>;
    /**
     * `getRGATreeSplit` returns rgaTreeSplit.
     *
     * @internal
     */
    getRGATreeSplit(): RGATreeSplit<CRDTTextValue>;
    /**
     * `getStructureAsString` returns a String containing the meta data of this value
     * for debugging purpose.
     */
    getStructureAsString(): string;
    /**
     * `getRemovedNodesLen` returns length of removed nodes
     */
    getRemovedNodesLen(): number;
    /**
     * `purgeTextNodesWithGarbage` physically purges nodes that have been removed.
     *
     * @internal
     */
    purgeTextNodesWithGarbage(ticket: TimeTicket): number;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTText<A>;
    private selectPriv;
    /**
     * `stringifyAttributes` makes values of attributes to JSON parsable string.
     */
    stringifyAttributes(attributes: A): Record<string, string>;
    /**
     * `parseAttributes` returns the JSON parsable string values to the origin states.
     */
    private parseAttributes;
}
/**
 * `CRDTTextElement` represents CRDTText.
 */
declare abstract class CRDTTextElement {
    abstract getRemovedNodesLen(): number;
    abstract purgeTextNodesWithGarbage(ticket: TimeTicket): number;
}
/**
 * `CRDTTextValue` is a value of Text
 * which has a attributes that expresses the text style.
 * Attributes are represented by RHT.
 *
 * @internal
 */
declare class CRDTTextValue {
    private attributes;
    private content;
    private constructor();
    /**
     * `create` creates a instance of CRDTTextValue.
     */
    static create(content: string): CRDTTextValue;
    /**
     * `length` returns the length of value.
     */
    get length(): number;
    /**
     * `substring` returns a sub-string value of the given range.
     */
    substring(indexStart: number, indexEnd: number): CRDTTextValue;
    /**
     * `setAttr` sets attribute of the given key, updated time and value.
     */
    setAttr(key: string, content: string, updatedAt: TimeTicket): void;
    /**
     * `getAttr` returns the attributes of this value.
     */
    getAttrs(): RHT;
    /**
     * `toString` returns the string representation of this value.
     */
    toString(): string;
    /**
     * `toJSON` returns the JSON encoding of this value.
     */
    toJSON(): string;
    /**
     * `getAttributes` returns the attributes of this value.
     */
    getAttributes(): Record<string, string>;
    /**
     * `getContent` returns the internal content.
     */
    getContent(): string;
}
/**
 * `CRDTTree` is a CRDT implementation of a tree.
 */
declare class CRDTTree {
    private dummyHead;
    private indexTree;
    private nodeMapByPos;
    constructor(root: CRDTTreeNode, createdAt: TimeTicket);
    /**
     * `create` creates a new instance of `CRDTTree`.
     */
    static create(root: CRDTTreeNode, ticket: TimeTicket): CRDTTree;
    /**
     * `nodesBetweenByTree` returns the nodes between the given range.
     */
    nodesBetweenByTree(from: number, to: number, callback: (node: CRDTTreeNode) => void): void;
    /**
     * `nodesBetween` returns the nodes between the given range.
     * This method includes the given left node but excludes the given right node.
     */
    nodesBetween(left: CRDTTreeNode, right: CRDTTreeNode, callback: (node: CRDTTreeNode) => void): void;
    /**
     * `findPostorderRight` finds the right node of the given index in postorder.
     */
    findPostorderRight(index: number): CRDTTreeNode | undefined;
    /**
     * `findTreePosWithSplitText` finds `TreePos` of the given `CRDTTreePos` and
     * splits the text node if necessary.
     *
     * `CRDTTreePos` is a position in the CRDT perspective. This is
     * different from `TreePos` which is a position of the tree in the local
     * perspective.
     */
    findTreePosWithSplitText(pos: CRDTTreePos, editedAt: TimeTicket): [
        TreePos<CRDTTreeNode>,
        CRDTTreeNode
    ];
    /**
     * `insertAfter` inserts the given node after the given previous node.
     */
    insertAfter(prevNode: CRDTTreeNode, newNode: CRDTTreeNode): void;
    /**
     * `edit` edits the tree with the given range and content.
     * If the content is undefined, the range will be removed.
     */
    edit(range: [
        CRDTTreePos,
        CRDTTreePos
    ], content: CRDTTreeNode | undefined, editedAt: TimeTicket): Array<TreeChange>;
    /**
     * `editByIndex` edits the given range with the given value.
     * This method uses indexes instead of a pair of TreePos for testing.
     */
    editByIndex(range: [
        number,
        number
    ], content: CRDTTreeNode | undefined, editedAt: TimeTicket): void;
    /**
     * `split` splits the node at the given index.
     */
    split(index: number, depth?: number): TreePos<CRDTTreeNode>;
    /**
     * `move` move the given source range to the given target range.
     */
    move(target: [
        number,
        number
    ], source: [
        number,
        number
    ], ticket: TimeTicket): void;
    /**
     * `findTreePos` finds the position of the given index in the tree.
     */
    findPos(index: number, preferText?: boolean): CRDTTreePos;
    /**
     * `pathToPos` finds the position of the given index in the tree by path.
     */
    pathToPos(path: Array<number>): CRDTTreePos;
    /**
     * `getRoot` returns the root node of the tree.
     */
    getRoot(): CRDTTreeNode;
    /**
     * `getSize` returns the size of the tree.
     */
    getSize(): number;
    /**
     * `getIndexTree` returns the index tree.
     */
    getIndexTree(): IndexTree<CRDTTreeNode>;
    /**
     * toXML returns the XML encoding of this tree.
     */
    toXML(): string;
    /**
     * `toJSON` returns the JSON encoding of this tree.
     */
    toJSON(): string;
    /**
     * `toStructure` returns the JSON of this tree for debugging.
     */
    toStructure(): TreeNodeForTest;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this tree.
     */
    toSortedJSON(): string;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTTree;
    /**
     * `Symbol.iterator` returns the iterator of the tree.
     */
    [Symbol.iterator](): IterableIterator<CRDTTreeNode>;
    /**
     * `toIndex` converts the given CRDTTreePos to the index of the tree.
     */
    private toIndex;
    /**
     * `toTreePos` converts the given CRDTTreePos to TreePos<CRDTTreeNode>.
     */
    private toTreePos;
    /**
     * `indexToPath` converts the given tree index to path.
     */
    indexToPath(index: number): Array<number>;
}
/**
 * `CRDTTreeNode` is a node of CRDTTree. It is includes the logical clock and
 * links to other nodes to resolve conflicts.
 */
declare class CRDTTreeNode {
    pos: CRDTTreePos;
    removedAt?: TimeTicket;
    /**
     * `next` is the next node of this node in the list.
     */
    next?: CRDTTreeNode;
    /**
     * `prev` is the previous node of this node in the list.
     */
    prev?: CRDTTreeNode;
    /**
     * `insPrev` is the previous node of this node after the node is split.
     */
    insPrev?: CRDTTreeNode;
    _value: string;
    constructor(pos: CRDTTreePos, type: string, opts?: string | Array<CRDTTreeNode>);
    /**
     * `create` creates a new instance of CRDTTreeNode.
     */
    static create(pos: CRDTTreePos, type: string, opts?: string | Array<CRDTTreeNode>): CRDTTreeNode;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): CRDTTreeNode;
    /**
     * `value` returns the value of the node.
     */
    get value(): string;
    /**
     * `value` sets the value of the node.
     */
    set value(v: string);
    /**
     * `isRemoved` returns whether the node is removed or not.
     */
    get isRemoved(): boolean;
    /**
     * `remove` marks the node as removed.
     */
    remove(removedAt: TimeTicket): void;
    /**
     * `clone` clones this node with the given offset.
     */
    clone(offset: number): CRDTTreeNode;
}
/**
 * `CRDTTreePos` represent a position in the tree. It indicates the virtual
 * location in the tree, so whether the node is splitted or not, we can find
 * the adjacent node to pos by calling `map.floorEntry()`.
 */
declare interface CRDTTreePos {
    /**
     * `createdAt` is the creation time of the node.
     */
    createdAt: TimeTicket;
    /**
     * `offset` is the distance from the beginning of the node if the node is
     * split.
     */
    offset: number;
}
/**
 * `DefaultTextType` is the default type of the text node.
 * It is used when the type of the text node is not specified.
 */
declare const DefaultTextType = "text";
/**
 * `DocEvent` is an event that occurs in `Document`. It can be delivered
 * using `Document.subscribe()`.
 *
 * @public
 */
export declare type DocEvent = SnapshotEvent | LocalChangeEvent | RemoteChangeEvent;
/**
 * `DocEventType` is document event types
 * @public
 */
export declare enum DocEventType {
    /**
     * snapshot event type
     */
    Snapshot = "snapshot",
    /**
     * local document change event type
     */
    LocalChange = "local-change",
    /**
     * remote document change event type
     */
    RemoteChange = "remote-change"
}
/**
 * `Document` is a CRDT-based data type. We can represent the model
 * of the application and edit it even while offline.
 *
 * @public
 */
declare class Document_2<T> {
    private key;
    private status;
    private root;
    private clone?;
    private changeID;
    private checkpoint;
    private localChanges;
    private eventStream;
    private eventStreamObserver;
    constructor(key: string);
    /**
     * `create` creates a new instance of Document.
     */
    static create<T>(key: string): Document_2<T>;
    /**
     * `update` executes the given updater to update this document.
     */
    update(updater: (root: JSONObject<T>) => void, message?: string): void;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the document is changed.
     */
    subscribe(nextOrObserver: Observer<DocEvent> | NextFn<DocEvent>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    /**
     * `subscribe` registers a callback to subscribe to events on the document.
     * The callback will be called when the targetPath or any of its nested values change.
     */
    subscribe(targetPath: string, next: NextFn<DocEvent>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    private isSameElementOrChildOf;
    /**
     * `applyChangePack` applies the given change pack into this document.
     * 1. Remove local changes applied to server.
     * 2. Update the checkpoint.
     * 3. Do Garbage collection.
     *
     * @param pack - change pack
     * @internal
     */
    applyChangePack(pack: ChangePack): void;
    /**
     * `getCheckpoint` returns the checkpoint of this document.
     *
     * @internal
     */
    getCheckpoint(): Checkpoint;
    /**
     * `hasLocalChanges` returns whether this document has local changes or not.
     *
     * @internal
     */
    hasLocalChanges(): boolean;
    /**
     * `ensureClone` make a clone of root.
     *
     * @internal
     */
    ensureClone(): void;
    /**
     * `createChangePack` create change pack of the local changes to send to the
     * remote server.
     *
     * @internal
     */
    createChangePack(): ChangePack;
    /**
     * `setActor` sets actor into this document. This is also applied in the local
     * changes the document has.
     *
     * @internal
     */
    setActor(actorID: ActorID): void;
    /**
     * `getKey` returns the key of this document.
     *
     * @internal
     */
    getKey(): string;
    /**
     * `setStatus` updates the status of this document.
     *
     * @internal
     */
    setStatus(status: DocumentStatus): void;
    /**
     * `getStatus` returns the status of this document.
     *
     * @internal
     */
    getStatus(): DocumentStatus;
    /**
     * `getClone` return clone object.
     *
     * @internal
     */
    getClone(): CRDTObject | undefined;
    /**
     * `getRoot` returns a new proxy of cloned root.
     */
    getRoot(): JSONObject<T>;
    /**
     * `garbageCollect` purges elements that were removed before the given time.
     *
     * @internal
     */
    garbageCollect(ticket: TimeTicket): number;
    /**
     * `getRootObject` returns root object.
     *
     * @internal
     */
    getRootObject(): CRDTObject;
    /**
     * `getGarbageLen` returns the length of elements should be purged.
     *
     * @internal
     */
    getGarbageLen(): number;
    /**
     * `toJSON` returns the JSON encoding of this document.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of this document.
     */
    toSortedJSON(): string;
    /**
     * `applySnapshot` applies the given snapshot into this document.
     */
    applySnapshot(serverSeq: Long_2, snapshot?: Uint8Array): void;
    /**
     * `applyChanges` applies the given changes into this document.
     */
    applyChanges(changes: Array<Change>): void;
    /**
     * `getValueByPath` returns the JSONElement corresponding to the given path.
     */
    getValueByPath(path: string): JSONElement | undefined;
    private createPaths;
    private toOperationInfo;
}
export { Document_2 as Document };
/**
 * Document key type
 * @public
 */
declare type DocumentKey = string;
/**
 * `DocumentsChangedEvent` is an event that occurs when documents attached to
 * the client changes.
 *
 * @public
 */
export declare interface DocumentsChangedEvent {
    /**
     * enum {@link ClientEventType}.DocumentsChangedEvent
     */
    type: ClientEventType.DocumentsChanged;
    /**
     * `DocumentsChangedEvent` value
     */
    value: Array<string>;
}
/**
 * `DocumentStatus` represents the status of the document.
 * @public
 */
declare enum DocumentStatus {
    /**
     * Detached means that the document is not attached to the client.
     * The actor of the ticket is created without being assigned.
     */
    Detached = "detached",
    /**
     * Attached means that this document is attached to the client.
     * The actor of the ticket is created with being assigned by the client.
     */
    Attached = "attached",
    /**
     * Removed means that this document is removed. If the document is removed,
     * it cannot be edited.
     */
    Removed = "removed"
}
/**
 * `DocumentSyncedEvent` is an event that occurs when documents
 * attached to the client are synced.
 *
 * @public
 */
export declare interface DocumentSyncedEvent {
    /**
     * `DocumentSyncedEvent` type
     * enum {@link ClientEventType}.DocumentSyncedEvent
     */
    type: ClientEventType.DocumentSynced;
    /**
     * `DocumentSyncedEvent` value
     */
    value: DocumentSyncResultType;
}
/**
 * `DocumentSyncResultType` represents the result of synchronizing the document
 *  with the server.
 * @public
 */
export declare enum DocumentSyncResultType {
    /**
     * type when Document synced successfully.
     */
    Synced = "synced",
    /**
     * type when Document sync failed.
     */
    SyncFailed = "sync-failed"
}
export declare type EditOpInfo = {
    type: 'edit';
    from: number;
    to: number;
    path: string;
    value: {
        attributes: Indexable;
        content: string;
    };
};
/**
 * `ElementNode` is a node that has children.
 */
export declare type ElementNode = {
    type: TreeNodeType;
    children: Array<TreeNode>;
};
/**
 * ElementRHT is a hashtable with logical clock(Replicated hashtable)
 *
 * @internal
 */
declare class ElementRHT {
    private nodeMapByKey;
    private nodeMapByCreatedAt;
    constructor();
    /**
     * `create` creates an instance of ElementRHT.
     */
    static create(): ElementRHT;
    /**
     * `set` sets the value of the given key.
     */
    set(key: string, value: Primitive): Primitive | undefined;
    /**
     * `delete` deletes the Element of the given key.
     */
    delete(createdAt: TimeTicket, executedAt: TimeTicket): Primitive;
    /**
     * `subPathOf` returns the sub path of the given element.
     */
    subPathOf(createdAt: TimeTicket): string | undefined;
    /**
     * `purge` physically purge child element.
     */
    purge(element: Primitive): void;
    /**
     * `deleteByKey` deletes the Element of the given key and removed time.
     */
    deleteByKey(key: string, removedAt: TimeTicket): Primitive | undefined;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `get` returns the value of the given key.
     */
    get(key: string): Primitive | undefined;
    [Symbol.iterator](): IterableIterator<ElementRHTNode>;
}
/**
 * `ElementRHTNode` is a node of ElementRHT.
 */
declare class ElementRHTNode {
    private strKey;
    private value;
    constructor(strKey: string, value: Primitive);
    /**
     * `of` creates a instance of ElementRHTNode.
     */
    static of(strKey: string, value: Primitive): ElementRHTNode;
    /**
     * `isRemoved` checks whether this value was removed.
     */
    isRemoved(): boolean;
    /**
     * `getStrKey` returns the key of this node.
     */
    getStrKey(): string;
    /**
     * `getValue` return the value(element) of this node
     */
    getValue(): Primitive;
    /**
     * `remove` removes a value base on removing time.
     */
    remove(removedAt: TimeTicket): boolean;
}
/**
 * @internal
 */
export declare type ErrorFn = (error: Error) => void;
declare type Executor<T> = (observer: Observer<T>) => void;
/**
 * `fromChangePack` converts the given Protobuf format to model format.
 */
declare function fromChangePack(pbPack: ChangePack_2): ChangePack;
/**
 * `fromChanges` converts the given Protobuf format to model format.
 */
declare function fromChanges(pbChanges: Array<Change_2>): Array<Change>;
/**
 * `fromPresence` converts the given Protobuf format to model format.
 */
declare function fromPresence<M>(pbPresence: Presence): PresenceInfo<M>;
export declare type IncreaseOpInfo = {
    type: 'increase';
    path: string;
    value: number;
};
/**
 * Indexable key, value
 * @public
 */
export declare type Indexable = Record<string, any>;
/**
 * `IndexTree` is a tree structure for linear indexing.
 */
declare class IndexTree<T extends IndexTreeNode<T>> {
    private root;
    constructor(root: T);
    /**
     * `nodeBetween` returns the nodes between the given range.
     */
    nodesBetween(from: number, to: number, callback: (node: T) => void): void;
    /**
     * `traverse` traverses the tree with postorder traversal.
     */
    traverse(callback: (node: T) => void): void;
    /**
     * `split` splits the node at the given index.
     */
    split(index: number, depth?: number): TreePos<T>;
    /**
     * findTreePos finds the position of the given index in the tree.
     */
    findTreePos(index: number, preferText?: boolean): TreePos<T>;
    /**
     * `treePosToPath` returns path from given treePos
     */
    treePosToPath(treePos: TreePos<T>): number[];
    /**
     * `pathToTreePos` returns treePos from given path
     */
    pathToTreePos(path: Array<number>): TreePos<T>;
    /**
     * `getRoot` returns the root node of the tree.
     */
    getRoot(): T;
    /**
     * `getSize` returns the size of the tree.
     */
    get size(): number;
    /**
     * `findPostorderRight` finds right node of the given tree position with
     *  postorder traversal.
     */
    findPostorderRight(treePos: TreePos<T>): T | undefined;
    /**
     * `indexOf` returns the index of the given tree position.
     */
    indexOf(pos: TreePos<T>): number;
    /**
     * `indexToPath` returns the path of the given index.
     */
    indexToPath(index: number): Array<number>;
}
/**
 * `IndexTreeNode` is the node of IndexTree. It is used to represent the
 * document of text-based editors.
 */
declare abstract class IndexTreeNode<T extends IndexTreeNode<T>> {
    type: TreeNodeType;
    parent?: T;
    _children: Array<T>;
    size: number;
    constructor(type: TreeNodeType, children?: Array<T>);
    /**
     * `updateAncestorsSize` updates the size of the ancestors.
     */
    updateAncestorsSize(): void;
    /**
     * `isText` returns true if the node is a text node.
     */
    get isText(): boolean;
    /**
     * `paddedSize` returns the size of the node including padding size.
     */
    get paddedSize(): number;
    /**
     * `isAncenstorOf` returns true if the node is an ancestor of the given node.
     */
    isAncestorOf(node: T): boolean;
    /**
     * `nextSibling` returns the next sibling of the node.
     */
    get nextSibling(): T | undefined;
    /**
     * `split` splits the node at the given offset.
     */
    split(offset: number): T | undefined;
    /**
     * `isRemoved` returns true if the node is removed.
     */
    abstract get isRemoved(): boolean;
    /**
     * `clone` clones the node with the given id and value.
     */
    abstract clone(offset: number): T;
    /**
     * `value` returns the value of the node.
     */
    abstract get value(): string;
    /**
     * `value` sets the value of the node.
     */
    abstract set value(v: string);
    /**
     * `splitText` splits the given node at the given offset.
     */
    splitText(offset: number): T | undefined;
    /**
     * `children` returns the children of the node.
     */
    get children(): Array<T>;
    /**
     * `hasTextChild` returns true if the node has an text child.
     */
    hasTextChild(): boolean;
    /**
     * `append` appends the given nodes to the children.
     */
    append(...newNode: Array<T>): void;
    /**
     * `prepend` prepends the given nodes to the children.
     */
    prepend(...newNode: Array<T>): void;
    /**
     * `insertBefore` inserts the given node before the given child.
     */
    insertBefore(newNode: T, referenceNode: T): void;
    /**
     * `insertAfter` inserts the given node after the given child.
     */
    insertAfter(newNode: T, referenceNode: T): void;
    /**
     * `insertAt` inserts the given node at the given offset.
     */
    insertAt(newNode: T, offset: number): void;
    /**
     * `removeChild` removes the given child.
     */
    removeChild(child: T): void;
    /**
     * `splitElement` splits the given element at the given offset.
     */
    splitElement(offset: number): T | undefined;
    /**
     * `insertAfterInternal` inserts the given node after the given child.
     * This method does not update the size of the ancestors.
     */
    insertAfterInternal(newNode: T, referenceNode: T): void;
    /**
     * `insertAtInternal` inserts the given node at the given index.
     * This method does not update the size of the ancestors.
     */
    insertAtInternal(newNode: T, offset: number): void;
    /**
     * findOffset returns the offset of the given node in the children.
     * It excludes the removed nodes.
     */
    findOffset(node: T): number;
    /**
     * `findBranchOffset` returns offset of the given descendant node in this node.
     * If the given node is not a descendant of this node, it returns -1.
     */
    findBranchOffset(node: T): number;
}
/**
 * `InternalOpInfo` represents the information of the operation. It is used to
 * internally and can be converted to `OperationInfo` to inform to the user.
 */
declare type InternalOpInfo = ToInternalOpInfo<AddOpInfo> | ToInternalOpInfo<IncreaseOpInfo> | ToInternalOpInfo<RemoveOpInfo> | ToInternalOpInfo<SetOpInfo> | ToInternalOpInfo<MoveOpInfo> | ToInternalOpInfo<EditOpInfo> | ToInternalOpInfo<StyleOpInfo> | ToInternalOpInfo<SelectOpInfo> | ToInternalOpInfo<TreeEditOpInfo>;
/**
 * `JSONArray` represents JSON array, but unlike regular JSON, it has time
 * tickets created by a logical clock to resolve conflicts.
 */
export declare type JSONArray<T> = {
    /**
     * `getID` returns the ID, `TimeTicket` of this Object.
     */
    getID?(): TimeTicket;
    /**
     * `getElementByID` returns the element for the given ID.
     */
    getElementByID?(createdAt: TimeTicket): WrappedElement<T>;
    /**
     * `getElementByIndex` returns the element for the given index.
     */
    getElementByIndex?(index: number): WrappedElement<T>;
    /**
     * `getLast` returns the last element of this array.
     */
    getLast?(): WrappedElement<T>;
    /**
     * `deleteByID` deletes the element of the given ID.
     */
    deleteByID?(createdAt: TimeTicket): WrappedElement<T>;
    /**
     * `insertBefore` inserts a value before the given next element.
     */
    insertBefore?(nextID: TimeTicket, value: any): WrappedElement<T>;
    /**
     * `insertAfter` inserts a value after the given previous element.
     */
    insertAfter?(prevID: TimeTicket, value: any): WrappedElement<T>;
    /**
     * `moveBefore` moves the element before the given next element.
     */
    moveBefore?(nextID: TimeTicket, id: TimeTicket): void;
    /**
     * `moveAfter` moves the element after the given previous element.
     */
    moveAfter?(prevID: TimeTicket, id: TimeTicket): void;
    /**
     * `moveFront` moves the element before the first element.
     */
    moveFront?(id: TimeTicket): void;
    /**
     * `moveLast` moves the element after the last element.
     */
    moveLast?(id: TimeTicket): void;
    /**
     * `getStructureAsString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    getStructureAsString?(): string;
} & Array<T>;
/**
 * `JSONElement` is a wrapper for `CRDTElement` that provides users with an
 * easy-to-use interface for manipulating `Document`s.
 */
export declare type JSONElement<T = unknown, A extends Indexable = Indexable> = PrimitiveValue | JSONObject<T> | JSONArray<T> | Text_2<A> | Counter | Tree;
declare class JSONElementSimple {
    getCreatedAt(): TimeTicket_2 | undefined;
    setCreatedAt(value?: TimeTicket_2): JSONElementSimple;
    hasCreatedAt(): boolean;
    clearCreatedAt(): JSONElementSimple;
    getMovedAt(): TimeTicket_2 | undefined;
    setMovedAt(value?: TimeTicket_2): JSONElementSimple;
    hasMovedAt(): boolean;
    clearMovedAt(): JSONElementSimple;
    getRemovedAt(): TimeTicket_2 | undefined;
    setRemovedAt(value?: TimeTicket_2): JSONElementSimple;
    hasRemovedAt(): boolean;
    clearRemovedAt(): JSONElementSimple;
    getType(): ValueType;
    setType(value: ValueType): JSONElementSimple;
    getValue(): Uint8Array | string;
    getValue_asU8(): Uint8Array;
    getValue_asB64(): string;
    setValue(value: Uint8Array | string): JSONElementSimple;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): JSONElementSimple.AsObject;
    static toObject(includeInstance: boolean, msg: JSONElementSimple): JSONElementSimple.AsObject;
    static serializeBinaryToWriter(message: JSONElementSimple, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): JSONElementSimple;
    static deserializeBinaryFromReader(message: JSONElementSimple, reader: jspb.BinaryReader): JSONElementSimple;
}
declare namespace JSONElementSimple {
    type AsObject = {
        createdAt?: TimeTicket_2.AsObject;
        movedAt?: TimeTicket_2.AsObject;
        removedAt?: TimeTicket_2.AsObject;
        type: ValueType;
        value: Uint8Array | string;
    };
}
/**
 * `JSONObject` represents a JSON object, but unlike regular JSON, it has time
 * tickets created by a logical clock to resolve conflicts.
 */
export declare type JSONObject<T> = {
    /**
     * `getID` returns the ID(time ticket) of this Object.
     */
    getID?(): TimeTicket;
    /**
     * `toJSON` returns the JSON encoding of this object.
     */
    toJSON?(): string;
    /**
     * `toJS` returns the JSON object of this object.
     */
    toJS?(): T;
} & T;
/**
 * `LocalChangeEvent` is an event that occurs when the document is changed
 * by local changes.
 *
 * @public
 */
export declare interface LocalChangeEvent {
    /**
     * enum {@link DocEventType}.LocalChange
     */
    type: DocEventType.LocalChange;
    /**
     * LocalChangeEvent type
     */
    value: ChangeInfo;
}
export declare type MoveOpInfo = {
    type: 'move';
    path: string;
    previousIndex: number;
    index: number;
};
/**
 * @internal
 */
export declare type NextFn<T> = (value: T) => void;
/**
 * `objectToBytes` converts the given JSONObject to byte array.
 */
declare function objectToBytes(obj: CRDTObject): Uint8Array;
/**
 * @internal
 */
export declare interface Observable<T> {
    subscribe: SubscribeFn<T>;
    getProxy?: () => Observer<T>;
}
/**
 * @internal
 */
export declare interface Observer<T> {
    next: NextFn<T>;
    error?: ErrorFn;
    complete?: CompleteFn;
}
/**
 * `ObserverProxy` is proxy of `Observer`.
 */
declare class ObserverProxy<T> implements Observer<T> {
    finalized: boolean;
    private observers;
    private finalError?;
    constructor(executor: Executor<T>);
    /**
     * `next` iterates next observer synchronously.
     */
    next(value: T): void;
    /**
     * `error` invoke error.
     */
    error(error: Error): void;
    /**
     * `complete` completes observer.
     */
    complete(): void;
    /**
     * `subscribe` is a function for subscribing observer.
     */
    subscribe(nextOrObserver: Observer<T> | NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    private unsubscribeOne;
    private forEachObserver;
    private sendOne;
    private close;
}
/**
 * `Operation` represents an operation to be executed on a document.
 */
declare abstract class Operation {
    private parentCreatedAt;
    private executedAt;
    constructor(parentCreatedAt: TimeTicket, executedAt: TimeTicket);
    /**
     * `getParentCreatedAt` returns the creation time of the target element to
     * execute the operation.
     */
    getParentCreatedAt(): TimeTicket;
    /**
     * `getExecutedAt` returns execution time of this operation.
     */
    getExecutedAt(): TimeTicket;
    /**
     * `setActor` sets the given actor to this operation.
     */
    setActor(actorID: ActorID): void;
    /**
     * `getEffectedCreatedAt` returns the creation time of the effected element.
     */
    abstract getEffectedCreatedAt(): TimeTicket;
    /**
     * `getStructureAsString` returns a string containing the meta data.
     */
    abstract getStructureAsString(): string;
    /**
     * `execute` executes this operation on the given `CRDTRoot`.
     */
    abstract execute(root: CRDTRoot): Array<InternalOpInfo>;
}
declare class Operation_2 {
    getSet(): Operation_2.Set | undefined;
    setSet(value?: Operation_2.Set): Operation_2;
    hasSet(): boolean;
    clearSet(): Operation_2;
    getAdd(): Operation_2.Add | undefined;
    setAdd(value?: Operation_2.Add): Operation_2;
    hasAdd(): boolean;
    clearAdd(): Operation_2;
    getMove(): Operation_2.Move | undefined;
    setMove(value?: Operation_2.Move): Operation_2;
    hasMove(): boolean;
    clearMove(): Operation_2;
    getRemove(): Operation_2.Remove | undefined;
    setRemove(value?: Operation_2.Remove): Operation_2;
    hasRemove(): boolean;
    clearRemove(): Operation_2;
    getEdit(): Operation_2.Edit | undefined;
    setEdit(value?: Operation_2.Edit): Operation_2;
    hasEdit(): boolean;
    clearEdit(): Operation_2;
    getSelect(): Operation_2.Select | undefined;
    setSelect(value?: Operation_2.Select): Operation_2;
    hasSelect(): boolean;
    clearSelect(): Operation_2;
    getStyle(): Operation_2.Style | undefined;
    setStyle(value?: Operation_2.Style): Operation_2;
    hasStyle(): boolean;
    clearStyle(): Operation_2;
    getIncrease(): Operation_2.Increase | undefined;
    setIncrease(value?: Operation_2.Increase): Operation_2;
    hasIncrease(): boolean;
    clearIncrease(): Operation_2;
    getTreeEdit(): Operation_2.TreeEdit | undefined;
    setTreeEdit(value?: Operation_2.TreeEdit): Operation_2;
    hasTreeEdit(): boolean;
    clearTreeEdit(): Operation_2;
    getBodyCase(): Operation_2.BodyCase;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Operation_2.AsObject;
    static toObject(includeInstance: boolean, msg: Operation_2): Operation_2.AsObject;
    static serializeBinaryToWriter(message: Operation_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Operation_2;
    static deserializeBinaryFromReader(message: Operation_2, reader: jspb.BinaryReader): Operation_2;
}
declare namespace Operation_2 {
    type AsObject = {
        set?: Operation_2.Set.AsObject;
        add?: Operation_2.Add.AsObject;
        move?: Operation_2.Move.AsObject;
        remove?: Operation_2.Remove.AsObject;
        edit?: Operation_2.Edit.AsObject;
        select?: Operation_2.Select.AsObject;
        style?: Operation_2.Style.AsObject;
        increase?: Operation_2.Increase.AsObject;
        treeEdit?: Operation_2.TreeEdit.AsObject;
    };
    class Set {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Set;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Set;
        getKey(): string;
        setKey(value: string): Set;
        getValue(): JSONElementSimple | undefined;
        setValue(value?: JSONElementSimple): Set;
        hasValue(): boolean;
        clearValue(): Set;
        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Set;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Set;
        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Set.AsObject;
        static toObject(includeInstance: boolean, msg: Set): Set.AsObject;
        static serializeBinaryToWriter(message: Set, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Set;
        static deserializeBinaryFromReader(message: Set, reader: jspb.BinaryReader): Set;
    }
    namespace Set {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject;
            key: string;
            value?: JSONElementSimple.AsObject;
            executedAt?: TimeTicket_2.AsObject;
        };
    }
    class Add {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Add;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Add;
        getPrevCreatedAt(): TimeTicket_2 | undefined;
        setPrevCreatedAt(value?: TimeTicket_2): Add;
        hasPrevCreatedAt(): boolean;
        clearPrevCreatedAt(): Add;
        getValue(): JSONElementSimple | undefined;
        setValue(value?: JSONElementSimple): Add;
        hasValue(): boolean;
        clearValue(): Add;
        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Add;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Add;
        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Add.AsObject;
        static toObject(includeInstance: boolean, msg: Add): Add.AsObject;
        static serializeBinaryToWriter(message: Add, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Add;
        static deserializeBinaryFromReader(message: Add, reader: jspb.BinaryReader): Add;
    }
    namespace Add {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject;
            prevCreatedAt?: TimeTicket_2.AsObject;
            value?: JSONElementSimple.AsObject;
            executedAt?: TimeTicket_2.AsObject;
        };
    }
    class Move {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Move;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Move;
        getPrevCreatedAt(): TimeTicket_2 | undefined;
        setPrevCreatedAt(value?: TimeTicket_2): Move;
        hasPrevCreatedAt(): boolean;
        clearPrevCreatedAt(): Move;
        getCreatedAt(): TimeTicket_2 | undefined;
        setCreatedAt(value?: TimeTicket_2): Move;
        hasCreatedAt(): boolean;
        clearCreatedAt(): Move;
        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Move;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Move;
        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Move.AsObject;
        static toObject(includeInstance: boolean, msg: Move): Move.AsObject;
        static serializeBinaryToWriter(message: Move, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Move;
        static deserializeBinaryFromReader(message: Move, reader: jspb.BinaryReader): Move;
    }
    namespace Move {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject;
            prevCreatedAt?: TimeTicket_2.AsObject;
            createdAt?: TimeTicket_2.AsObject;
            executedAt?: TimeTicket_2.AsObject;
        };
    }
    class Remove {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Remove;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Remove;
        getCreatedAt(): TimeTicket_2 | undefined;
        setCreatedAt(value?: TimeTicket_2): Remove;
        hasCreatedAt(): boolean;
        clearCreatedAt(): Remove;
        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Remove;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Remove;
        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Remove.AsObject;
        static toObject(includeInstance: boolean, msg: Remove): Remove.AsObject;
        static serializeBinaryToWriter(message: Remove, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Remove;
        static deserializeBinaryFromReader(message: Remove, reader: jspb.BinaryReader): Remove;
    }
    namespace Remove {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject;
            createdAt?: TimeTicket_2.AsObject;
            executedAt?: TimeTicket_2.AsObject;
        };
    }
    class Edit {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Edit;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Edit;
        getFrom(): TextNodePos | undefined;
        setFrom(value?: TextNodePos): Edit;
        hasFrom(): boolean;
        clearFrom(): Edit;
        getTo(): TextNodePos | undefined;
        setTo(value?: TextNodePos): Edit;
        hasTo(): boolean;
        clearTo(): Edit;
        getCreatedAtMapByActorMap(): jspb.Map<string, TimeTicket_2>;
        clearCreatedAtMapByActorMap(): Edit;
        getContent(): string;
        setContent(value: string): Edit;
        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Edit;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Edit;
        getAttributesMap(): jspb.Map<string, string>;
        clearAttributesMap(): Edit;
        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Edit.AsObject;
        static toObject(includeInstance: boolean, msg: Edit): Edit.AsObject;
        static serializeBinaryToWriter(message: Edit, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Edit;
        static deserializeBinaryFromReader(message: Edit, reader: jspb.BinaryReader): Edit;
    }
    namespace Edit {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject;
            from?: TextNodePos.AsObject;
            to?: TextNodePos.AsObject;
            createdAtMapByActorMap: Array<[
                string,
                TimeTicket_2.AsObject
            ]>;
            content: string;
            executedAt?: TimeTicket_2.AsObject;
            attributesMap: Array<[
                string,
                string
            ]>;
        };
    }
    class Select {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Select;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Select;
        getFrom(): TextNodePos | undefined;
        setFrom(value?: TextNodePos): Select;
        hasFrom(): boolean;
        clearFrom(): Select;
        getTo(): TextNodePos | undefined;
        setTo(value?: TextNodePos): Select;
        hasTo(): boolean;
        clearTo(): Select;
        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Select;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Select;
        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Select.AsObject;
        static toObject(includeInstance: boolean, msg: Select): Select.AsObject;
        static serializeBinaryToWriter(message: Select, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Select;
        static deserializeBinaryFromReader(message: Select, reader: jspb.BinaryReader): Select;
    }
    namespace Select {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject;
            from?: TextNodePos.AsObject;
            to?: TextNodePos.AsObject;
            executedAt?: TimeTicket_2.AsObject;
        };
    }
    class Style {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Style;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Style;
        getFrom(): TextNodePos | undefined;
        setFrom(value?: TextNodePos): Style;
        hasFrom(): boolean;
        clearFrom(): Style;
        getTo(): TextNodePos | undefined;
        setTo(value?: TextNodePos): Style;
        hasTo(): boolean;
        clearTo(): Style;
        getAttributesMap(): jspb.Map<string, string>;
        clearAttributesMap(): Style;
        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Style;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Style;
        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Style.AsObject;
        static toObject(includeInstance: boolean, msg: Style): Style.AsObject;
        static serializeBinaryToWriter(message: Style, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Style;
        static deserializeBinaryFromReader(message: Style, reader: jspb.BinaryReader): Style;
    }
    namespace Style {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject;
            from?: TextNodePos.AsObject;
            to?: TextNodePos.AsObject;
            attributesMap: Array<[
                string,
                string
            ]>;
            executedAt?: TimeTicket_2.AsObject;
        };
    }
    class Increase {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): Increase;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): Increase;
        getValue(): JSONElementSimple | undefined;
        setValue(value?: JSONElementSimple): Increase;
        hasValue(): boolean;
        clearValue(): Increase;
        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): Increase;
        hasExecutedAt(): boolean;
        clearExecutedAt(): Increase;
        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): Increase.AsObject;
        static toObject(includeInstance: boolean, msg: Increase): Increase.AsObject;
        static serializeBinaryToWriter(message: Increase, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): Increase;
        static deserializeBinaryFromReader(message: Increase, reader: jspb.BinaryReader): Increase;
    }
    namespace Increase {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject;
            value?: JSONElementSimple.AsObject;
            executedAt?: TimeTicket_2.AsObject;
        };
    }
    class TreeEdit {
        getParentCreatedAt(): TimeTicket_2 | undefined;
        setParentCreatedAt(value?: TimeTicket_2): TreeEdit;
        hasParentCreatedAt(): boolean;
        clearParentCreatedAt(): TreeEdit;
        getFrom(): TreePos_2 | undefined;
        setFrom(value?: TreePos_2): TreeEdit;
        hasFrom(): boolean;
        clearFrom(): TreeEdit;
        getTo(): TreePos_2 | undefined;
        setTo(value?: TreePos_2): TreeEdit;
        hasTo(): boolean;
        clearTo(): TreeEdit;
        getContentList(): Array<TreeNode_3>;
        setContentList(value: Array<TreeNode_3>): TreeEdit;
        clearContentList(): TreeEdit;
        addContent(value?: TreeNode_3, index?: number): TreeNode_3;
        getExecutedAt(): TimeTicket_2 | undefined;
        setExecutedAt(value?: TimeTicket_2): TreeEdit;
        hasExecutedAt(): boolean;
        clearExecutedAt(): TreeEdit;
        serializeBinary(): Uint8Array;
        toObject(includeInstance?: boolean): TreeEdit.AsObject;
        static toObject(includeInstance: boolean, msg: TreeEdit): TreeEdit.AsObject;
        static serializeBinaryToWriter(message: TreeEdit, writer: jspb.BinaryWriter): void;
        static deserializeBinary(bytes: Uint8Array): TreeEdit;
        static deserializeBinaryFromReader(message: TreeEdit, reader: jspb.BinaryReader): TreeEdit;
    }
    namespace TreeEdit {
        type AsObject = {
            parentCreatedAt?: TimeTicket_2.AsObject;
            from?: TreePos_2.AsObject;
            to?: TreePos_2.AsObject;
            contentList: Array<TreeNode_3.AsObject>;
            executedAt?: TimeTicket_2.AsObject;
        };
    }
    enum BodyCase {
        BODY_NOT_SET = 0,
        SET = 1,
        ADD = 2,
        MOVE = 3,
        REMOVE = 4,
        EDIT = 5,
        SELECT = 6,
        STYLE = 7,
        INCREASE = 8,
        TREE_EDIT = 9
    }
}
/**
 * `OperationInfo` represents the information of an operation.
 * It is used to inform to the user what kind of operation was executed.
 */
export declare type OperationInfo = AddOpInfo | IncreaseOpInfo | RemoveOpInfo | SetOpInfo | MoveOpInfo | EditOpInfo | StyleOpInfo | SelectOpInfo | TreeEditOpInfo;
/**
 * `PeersChangedEvent` is an event that occurs when the states of another peers
 * of the attached documents changes.
 *
 * @public
 */
export declare interface PeersChangedEvent<P> {
    /**
     * enum {@link ClientEventType}.PeersChangedEvent
     */
    type: ClientEventType.PeersChanged;
    /**
     * `PeersChangedEvent` value
     */
    value: PeersChangedValue<P>;
}
/**
 * `PeersChangedValue` represents the value of the PeersChanged event.
 * @public
 */
declare type PeersChangedValue<P> = {
    type: 'initialized' | 'watched' | 'unwatched' | 'presence-changed';
    peers: Record<DocumentKey, Array<{
        clientID: ActorID;
        presence: P;
    }>>;
};
declare class Presence {
    getClock(): number;
    setClock(value: number): Presence;
    getDataMap(): jspb.Map<string, string>;
    clearDataMap(): Presence;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Presence.AsObject;
    static toObject(includeInstance: boolean, msg: Presence): Presence.AsObject;
    static serializeBinaryToWriter(message: Presence, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Presence;
    static deserializeBinaryFromReader(message: Presence, reader: jspb.BinaryReader): Presence;
}
declare namespace Presence {
    type AsObject = {
        clock: number;
        dataMap: Array<[
            string,
            string
        ]>;
    };
}
/**
 * `PresenceInfo` is presence information of this client.
 */
export declare type PresenceInfo<P> = {
    clock: number;
    data: P;
};
/**
 * `Primitive` represents primitive data type including logical clock.
 * It has a type and a value.
 */
export declare class Primitive {
    private valueType;
    private value;
    constructor(value: PrimitiveValue, createdAt: TimeTicket);
    /**
     * `of` creates a new instance of Primitive.
     */
    static of(value: PrimitiveValue, createdAt: TimeTicket): Primitive;
    /**
     * `valueFromBytes` parses the given bytes into value.
     */
    static valueFromBytes(primitiveType: PrimitiveType, bytes: Uint8Array): PrimitiveValue;
    /**
     * `toJSON` returns the JSON encoding of the value.
     */
    toJSON(): string;
    /**
     * `toSortedJSON` returns the sorted JSON encoding of the value.
     */
    toSortedJSON(): string;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): Primitive;
    /**
     * `getType` returns the type of the value.
     */
    getType(): PrimitiveType;
    /**
     * `getPrimitiveType` returns the primitive type of the value.
     */
    static getPrimitiveType(value: unknown): PrimitiveType | undefined;
    /**
     * `isSupport` check if the given value is supported type.
     */
    static isSupport(value: unknown): boolean;
    /**
     * `isInteger` checks if the given number is integer.
     */
    static isInteger(num: number): boolean;
    /**
     * `isNumericType` checks numeric type by JSONPrimitive
     */
    isNumericType(): boolean;
    /**
     * `getValue` returns the value of Primitive.
     */
    getValue(): PrimitiveValue;
    /**
     * `toBytes` creates an array representing the value.
     */
    toBytes(): Uint8Array;
}
declare enum PrimitiveType {
    Null = 0,
    Boolean = 1,
    Integer = 2,
    Long = 3,
    Double = 4,
    String = 5,
    Bytes = 6,
    Date = 7
}
/**
 * `PrimitiveValue` represents a value of primitive type. Only values of type
 * included in `PrimitiveValue` can be set to the document.
 */
export declare type PrimitiveValue = null | boolean | number | Long_2 | string | Uint8Array | Date;
/**
 * `RemoteChangeEvent` is an event that occurs when the document is changed
 * by remote changes.
 *
 * @public
 */
export declare interface RemoteChangeEvent {
    /**
     * enum {@link DocEventType}.RemoteChange
     */
    type: DocEventType.RemoteChange;
    /**
     * RemoteChangeEvent type
     */
    value: ChangeInfo;
}
export declare type RemoveOpInfo = {
    type: 'remove';
    path: string;
    key?: string;
    index?: number;
};
/**
 * `RGATreeSplit` is a block-based list with improved index-based lookup in RGA.
 * The difference from RGATreeList is that it has data on a block basis to
 * reduce the size of CRDT metadata. When an edit occurs on a block,
 * the block is split.
 *
 * @internal
 */
declare class RGATreeSplit<T extends RGATreeSplitValue> {
    private head;
    private treeByIndex;
    private treeByID;
    private removedNodeMap;
    constructor();
    /**
     * `create` creates a instance RGATreeSplit.
     */
    static create<T extends RGATreeSplitValue>(): RGATreeSplit<T>;
    /**
     * `edit` does following steps
     * 1. split nodes with from and to
     * 2. delete between from and to
     * 3. insert a new node
     * 4. add removed node
     * @param range - range of RGATreeSplitNode
     * @param editedAt - edited time
     * @param value - value
     * @param latestCreatedAtMapByActor - latestCreatedAtMapByActor
     * @returns `[RGATreeSplitNodePos, Map<string, TimeTicket>, Array<Change>]`
     */
    edit(range: RGATreeSplitNodeRange, editedAt: TimeTicket, value?: T, latestCreatedAtMapByActor?: Map<string, TimeTicket>): [
        RGATreeSplitNodePos,
        Map<string, TimeTicket>,
        Array<ValueChange<T>>
    ];
    /**
     * `findNodePos` finds RGATreeSplitNodePos of given offset.
     */
    findNodePos(idx: number): RGATreeSplitNodePos;
    /**
     * `findIndexesFromRange` finds indexes based on range.
     */
    findIndexesFromRange(range: RGATreeSplitNodeRange): [
        number,
        number
    ];
    /**
     * `findIdxFromNodePos` finds index based on node position.
     */
    findIdxFromNodePos(pos: RGATreeSplitNodePos, preferToLeft: boolean): number;
    /**
     * `findNode` finds node of given id.
     */
    findNode(id: RGATreeSplitNodeID): RGATreeSplitNode<T>;
    /**
     * `length` returns size of RGATreeSplit.
     */
    get length(): number;
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight(): boolean;
    /**
     * `toString` returns the string encoding of this RGATreeSplit.
     */
    toString(): string;
    [Symbol.iterator](): IterableIterator<RGATreeSplitNode<T>>;
    /**
     * `getHead` returns head of RGATreeSplitNode.
     */
    getHead(): RGATreeSplitNode<T>;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): RGATreeSplit<T>;
    /**
     * `getStructureAsString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    getStructureAsString(): string;
    /**
     * `insertAfter` inserts the given node after the given previous node.
     */
    insertAfter(prevNode: RGATreeSplitNode<T>, newNode: RGATreeSplitNode<T>): RGATreeSplitNode<T>;
    /**
     * `findNodeWithSplit` splits and return nodes of the given position.
     */
    findNodeWithSplit(pos: RGATreeSplitNodePos, editedAt: TimeTicket): [
        RGATreeSplitNode<T>,
        RGATreeSplitNode<T>
    ];
    private findFloorNodePreferToLeft;
    private findFloorNode;
    /**
     * `findBetween` returns nodes between fromNode and toNode.
     */
    findBetween(fromNode: RGATreeSplitNode<T>, toNode: RGATreeSplitNode<T>): Array<RGATreeSplitNode<T>>;
    private splitNode;
    private deleteNodes;
    private filterNodes;
    /**
     * `findEdgesOfCandidates` finds the edges outside `candidates`,
     * (which has not already been deleted, or be undefined but not yet implemented)
     * right edge is undefined means `candidates` contains the end of text.
     */
    private findEdgesOfCandidates;
    private makeChanges;
    /**
     * `deleteIndexNodes` clears the index nodes of the given deletion boundaries.
     * The boundaries mean the nodes that will not be deleted in the range.
     */
    private deleteIndexNodes;
    /**
     * `getRemovedNodesLen` returns size of removed nodes.
     */
    getRemovedNodesLen(): number;
    /**
     * `purgeTextNodesWithGarbage` physically purges nodes that have been removed.
     */
    purgeTextNodesWithGarbage(ticket: TimeTicket): number;
    /**
     * `purge` physically purges the given node from RGATreeSplit.
     */
    purge(node: RGATreeSplitNode<T>): void;
}
/**
 * `RGATreeSplitNode` is a node of RGATreeSplit.
 */
declare class RGATreeSplitNode<T extends RGATreeSplitValue> {
    private id;
    private removedAt?;
    private prev?;
    private next?;
    private insPrev?;
    private insNext?;
    constructor(id: RGATreeSplitNodeID, value?: T, removedAt?: TimeTicket);
    /**
     * `create` creates a instance of RGATreeSplitNode.
     */
    static create<T extends RGATreeSplitValue>(id: RGATreeSplitNodeID, value?: T): RGATreeSplitNode<T>;
    /**
     * `createComparator` creates a function to compare two RGATreeSplitNodeID.
     */
    static createComparator(): Comparator<RGATreeSplitNodeID>;
    /**
     * `getID` returns the ID of this RGATreeSplitNode.
     */
    getID(): RGATreeSplitNodeID;
    /**
     * `getCreatedAt` returns creation time of the Id of RGATreeSplitNode.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getLength` returns the length of this node.
     */
    getLength(): number;
    /**
     * `getContentLength` returns the length of this value.
     */
    getContentLength(): number;
    /**
     * `getPrev` returns a previous node of this node.
     */
    getPrev(): RGATreeSplitNode<T> | undefined;
    /**
     * `getNext` returns a next node of this node.
     */
    getNext(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsPrev` returns a previous node of this node insertion.
     */
    getInsPrev(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsNext` returns a next node of this node insertion.
     */
    getInsNext(): RGATreeSplitNode<T> | undefined;
    /**
     * `getInsPrevID` returns a ID of previous node insertion.
     */
    getInsPrevID(): RGATreeSplitNodeID;
    /**
     * `setPrev` sets previous node of this node.
     */
    setPrev(node?: RGATreeSplitNode<T>): void;
    /**
     * `setNext` sets next node of this node.
     */
    setNext(node?: RGATreeSplitNode<T>): void;
    /**
     * `setInsPrev` sets previous node of this node insertion.
     */
    setInsPrev(node?: RGATreeSplitNode<T>): void;
    /**
     * `setInsNext` sets next node of this node insertion.
     */
    setInsNext(node?: RGATreeSplitNode<T>): void;
    /**
     * `hasNext` checks if next node exists.
     */
    hasNext(): boolean;
    /**
     * `hasInsPrev` checks if previous insertion node exists.
     */
    hasInsPrev(): boolean;
    /**
     * `isRemoved` checks if removed time exists.
     */
    isRemoved(): boolean;
    /**
     * `getRemovedAt` returns the remove time of this node.
     */
    getRemovedAt(): TimeTicket | undefined;
    /**
     * `split` creates a new split node of the given offset.
     */
    split(offset: number): RGATreeSplitNode<T>;
    /**
     * `canDelete` checks if node is able to delete.
     */
    canDelete(editedAt: TimeTicket, latestCreatedAt: TimeTicket): boolean;
    /**
     * `remove` removes node of given edited time.
     */
    remove(editedAt?: TimeTicket): void;
    /**
     * `createRange` creates ranges of RGATreeSplitNodePos.
     */
    createRange(): RGATreeSplitNodeRange;
    /**
     * `deepcopy` returns a new instance of this RGATreeSplitNode without structural info.
     */
    deepcopy(): RGATreeSplitNode<T>;
    /**
     * `getStructureAsString` returns a String containing
     * the meta data of the node for debugging purpose.
     */
    getStructureAsString(): string;
    private splitValue;
}
/**
 * `RGATreeSplitNodeID` is an ID of RGATreeSplitNode.
 */
declare class RGATreeSplitNodeID {
    private createdAt;
    private offset;
    constructor(createdAt: TimeTicket, offset: number);
    /**
     * `of` creates a instance of RGATreeSplitNodeID.
     */
    static of(createdAt: TimeTicket, offset: number): RGATreeSplitNodeID;
    /**
     * `getCreatedAt` returns the creation time of this ID.
     */
    getCreatedAt(): TimeTicket;
    /**
     * `getOffset` returns returns the offset of this ID.
     */
    getOffset(): number;
    /**
     * `equals` returns whether given ID equals to this ID or not.
     */
    equals(other: RGATreeSplitNodeID): boolean;
    /**
     * `hasSameCreatedAt` returns whether given ID has same creation time with this ID.
     */
    hasSameCreatedAt(other: RGATreeSplitNodeID): boolean;
    /**
     * `split` creates a new ID with an offset from this ID.
     */
    split(offset: number): RGATreeSplitNodeID;
    /**
     * `getStructureAsString` returns a String containing
     * the meta data of the node id for debugging purpose.
     */
    getStructureAsString(): string;
}
/**
 * `RGATreeSplitNodePos` is the position of the text inside the node.
 */
declare class RGATreeSplitNodePos {
    private id;
    private relativeOffset;
    constructor(id: RGATreeSplitNodeID, relativeOffset: number);
    /**
     * `of` creates a instance of RGATreeSplitNodePos.
     */
    static of(id: RGATreeSplitNodeID, relativeOffset: number): RGATreeSplitNodePos;
    /**
     * `getID` returns the ID of this RGATreeSplitNodePos.
     */
    getID(): RGATreeSplitNodeID;
    /**
     * `getRelativeOffset` returns the relative offset of this RGATreeSplitNodePos.
     */
    getRelativeOffset(): number;
    /**
     * `getAbsoluteID` returns the absolute id of this RGATreeSplitNodePos.
     */
    getAbsoluteID(): RGATreeSplitNodeID;
    /**
     *`getStructureAsString` returns a String containing
     * the meta data of the position for debugging purpose.
     */
    getStructureAsString(): string;
    /**
     * `equals` returns whether given pos equal to this pos or not.
     */
    equals(other: RGATreeSplitNodePos): boolean;
}
/**
 * @internal
 */
declare type RGATreeSplitNodeRange = [
    RGATreeSplitNodePos,
    RGATreeSplitNodePos
];
declare interface RGATreeSplitValue {
    length: number;
    substring(indexStart: number, indexEnd?: number): RGATreeSplitValue;
}
/**
 * RHT is replicated hash table by creation time.
 * For more details about RHT: @see http://csl.skku.edu/papers/jpdc11.pdf
 */
declare class RHT {
    private nodeMapByKey;
    constructor();
    /**
     * `create` creates a new instance of RHT.
     */
    static create(): RHT;
    /**
     * `set` sets the value of the given key.
     */
    set(key: string, value: string, executedAt: TimeTicket): void;
    /**
     * `has` returns whether the element exists of the given key or not.
     */
    has(key: string): boolean;
    /**
     * `get` returns the value of the given key.
     */
    get(key: string): string | undefined;
    /**
     * `deepcopy` copies itself deeply.
     */
    deepcopy(): RHT;
    /**
     * `toJSON` returns the JSON encoding of this hashtable.
     */
    toJSON(): string;
    /**
     * `toObject` returns the object of this hashtable.
     */
    toObject(): Record<string, string>;
    [Symbol.iterator](): IterableIterator<RHTNode>;
}
/**
 * `RHTNode` is a node of RHT(Replicated Hashtable).
 */
declare class RHTNode {
    private key;
    private value;
    private updatedAt;
    constructor(key: string, value: string, updatedAt: TimeTicket);
    /**
     * `of` creates a new instance of RHTNode.
     */
    static of(key: string, value: string, createdAt: TimeTicket): RHTNode;
    /**
     * `getKey` returns a key of node.
     */
    getKey(): string;
    /**
     * `getValue` returns a value of node.
     */
    getValue(): string;
    /**
     * `getUpdatedAt `returns updated time of node.
     */
    getUpdatedAt(): TimeTicket;
}
export declare type SelectOpInfo = {
    type: 'select';
    from: number;
    to: number;
    path: string;
};
export declare type SetOpInfo = {
    type: 'set';
    path: string;
    key: string;
};
/**
 * `SnapshotEvent` is an event that occurs when a snapshot is received from
 * the server.
 *
 * @public
 */
export declare interface SnapshotEvent {
    /**
     * enum {@link DocEventType}.Snapshot
     */
    type: DocEventType.Snapshot;
    /**
     * SnapshotEvent type
     */
    value: Uint8Array | undefined;
}
/**
 * `SplayNode` is a node of SplayTree.
 */
declare abstract class SplayNode<V> {
    protected value: V;
    private left?;
    private right?;
    private parent?;
    private weight;
    constructor(value: V);
    abstract getLength(): number;
    /**
     * `getNodeString` returns a string of weight and value of this node.
     */
    getNodeString(): string;
    /**
     * `getValue` returns value of this node.
     */
    getValue(): V;
    /**
     * `getLeftWeight` returns left weight of this node.
     */
    getLeftWeight(): number;
    /**
     * `getRightWeight` returns right weight of this node.
     */
    getRightWeight(): number;
    /**
     * `getWeight` returns weight of this node.
     */
    getWeight(): number;
    /**
     * `getLeft` returns a left node.
     */
    getLeft(): SplayNode<V> | undefined;
    /**
     * `getRight` returns a right node.
     */
    getRight(): SplayNode<V> | undefined;
    /**
     * `getParent` returns parent of this node.
     */
    getParent(): SplayNode<V> | undefined;
    /**
     * `hasLeft` check if the left node exists
     */
    hasLeft(): boolean;
    /**
     * `hasRight` check if the right node exists
     */
    hasRight(): boolean;
    /**
     * `hasParent` check if the parent node exists
     */
    hasParent(): boolean;
    /**
     * `setLeft` sets a left node.
     */
    setLeft(left?: SplayNode<V>): void;
    /**
     * `setRight` sets a right node.
     */
    setRight(right?: SplayNode<V>): void;
    /**
     * `setParent` sets a parent node.
     */
    setParent(parent?: SplayNode<V>): void;
    /**
     * `unlink` unlink parent, right and left node.
     */
    unlink(): void;
    /**
     * `hasLinks` checks if parent, right and left node exists.
     */
    hasLinks(): boolean;
    /**
     * `increaseWeight` increases weight.
     */
    increaseWeight(weight: number): void;
    /**
     * `initWeight` sets initial weight of this node.
     */
    initWeight(): void;
}
/**
 * `StatusChangedEvent` is an event that occurs when the Client's state changes.
 *
 * @public
 */
export declare interface StatusChangedEvent {
    /**
     * enum {@link ClientEventType}.StatusChanged
     */
    type: ClientEventType.StatusChanged;
    /**
     * `DocumentsChangedEvent` value
     */
    value: ClientStatus;
}
/**
 * `StreamConnectionStatus` represents whether the stream connection between the
 * client and the server is connected or not.
 * @public
 */
export declare enum StreamConnectionStatus {
    /**
     * `Connected` means that the stream connection is connected.
     */
    Connected = "connected",
    /**
     * `Disconnected` means that the stream connection is disconnected.
     */
    Disconnected = "disconnected"
}
/**
 * `StreamConnectionStatusChangedEvent` is an event that occurs when
 * the client's stream connection state changes.
 *
 * @public
 */
export declare interface StreamConnectionStatusChangedEvent {
    /**
     * `StreamConnectionStatusChangedEvent` type
     * enum {@link ClientEventType}.StreamConnectionStatusChangedEvent
     */
    type: ClientEventType.StreamConnectionStatusChanged;
    /**
     * `StreamConnectionStatusChangedEvent` value
     */
    value: StreamConnectionStatus;
}
export declare type StyleOpInfo = {
    type: 'style';
    from: number;
    to: number;
    path: string;
    value: {
        attributes: Indexable;
    };
};
declare interface SubscribeFn<T> {
    (next: Observer<T> | NextFn<T>, error?: ErrorFn, complete?: CompleteFn): Unsubscribe;
    (observer: Observer<T>): Unsubscribe;
}
/**
 * `SyncMode` is the mode of synchronization. It is used to determine
 * whether to push and pull changes in PushPullChanges API.
 * @public
 */
export declare enum SyncMode {
    /**
     * `PushPull` is the mode that pushes and pulls changes.
     */
    PushPull = "pushpull",
    /**
     * `PushOnly` is the mode that pushes changes only.
     */
    PushOnly = "pushonly"
}
/**
 * `Text` is an extended data type for the contents of a text editor.
 */
declare class Text_2<A extends Indexable = Indexable> {
    private context?;
    private text?;
    constructor(context?: ChangeContext, text?: CRDTText<A>);
    /**
     * `initialize` initialize this text with context and internal text.
     * @internal
     */
    initialize(context: ChangeContext, text: CRDTText<A>): void;
    /**
     * `getID` returns the ID of this text.
     */
    getID(): TimeTicket;
    /**
     * `edit` edits this text with the given content.
     */
    edit(fromIdx: number, toIdx: number, content: string, attributes?: A): boolean;
    /**
     * `delete` deletes the text in the given range.
     */
    delete(fromIdx: number, toIdx: number): boolean;
    /**
     * `empty` makes the text empty.
     */
    empty(): boolean;
    /**
     * `setStyle` styles this text with the given attributes.
     */
    setStyle(fromIdx: number, toIdx: number, attributes: A): boolean;
    /**
     * `select` selects the given range.
     */
    select(fromIdx: number, toIdx: number): boolean;
    /**
     * `getStructureAsString` returns a String containing the meta data of the node
     * for debugging purpose.
     */
    getStructureAsString(): string;
    /**
     * `values` returns values of this text.
     */
    values(): Array<TextValueType<A>>;
    /**
     * `length` returns size of RGATreeList.
     */
    get length(): number;
    /**
     * `checkWeight` returns false when there is an incorrect weight node.
     * for debugging purpose.
     */
    checkWeight(): boolean;
    /**
     * `toString` returns the string representation of this text.
     */
    toString(): string;
    /**
     * `createRange` returns pair of RGATreeSplitNodePos of the given integer offsets.
     */
    createRange(fromIdx: number, toIdx: number): RGATreeSplitNodeRange;
}
export { Text_2 as Text };
/**
 * `TextChange` is the value passed as an argument to `Document.subscribe()`.
 * `Document.subscribe()` is called when the `Text` is modified.
 */
export declare interface TextChange<A = Indexable> extends ValueChange<TextValueType<A>> {
    type: TextChangeType;
}
/**
 * `TextChangeType` is the type of TextChange.
 *
 * @internal
 */
export declare enum TextChangeType {
    Content = "content",
    Selection = "selection",
    Style = "style"
}
/**
 * `TextNode` is a node that has a value.
 */
export declare type TextNode = {
    type: typeof DefaultTextType;
    value: string;
};
declare class TextNodePos {
    getCreatedAt(): TimeTicket_2 | undefined;
    setCreatedAt(value?: TimeTicket_2): TextNodePos;
    hasCreatedAt(): boolean;
    clearCreatedAt(): TextNodePos;
    getOffset(): number;
    setOffset(value: number): TextNodePos;
    getRelativeOffset(): number;
    setRelativeOffset(value: number): TextNodePos;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TextNodePos.AsObject;
    static toObject(includeInstance: boolean, msg: TextNodePos): TextNodePos.AsObject;
    static serializeBinaryToWriter(message: TextNodePos, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TextNodePos;
    static deserializeBinaryFromReader(message: TextNodePos, reader: jspb.BinaryReader): TextNodePos;
}
declare namespace TextNodePos {
    type AsObject = {
        createdAt?: TimeTicket_2.AsObject;
        offset: number;
        relativeOffset: number;
    };
}
/**
 * `TextValueType` is a value of Text
 * which has a attributes that expresses the text style.
 */
declare interface TextValueType<A> {
    attributes?: A;
    content?: string;
}
/**
 * `TimeTicket` is a timestamp of the logical clock. Ticket is immutable.
 * It is created by `ChangeID`.
 *
 * @public
 */
export declare class TimeTicket {
    private lamport;
    private delimiter;
    private actorID?;
    private constructor();
    /**
     * `of` creates an instance of Ticket.
     */
    static of(lamport: Long_2, delimiter: number, actorID?: string): TimeTicket;
    /**
     * `toIDString` returns the lamport string for this Ticket.
     */
    toIDString(): string;
    /**
     * `getStructureAsString` returns a string containing the meta data of the ticket
     * for debugging purpose.
     */
    getStructureAsString(): string;
    /**
     * `setActor` creates a new instance of Ticket with the given actorID.
     */
    setActor(actorID: ActorID): TimeTicket;
    /**
     * `getLamportAsString` returns the lamport string.
     */
    getLamportAsString(): string;
    /**
     * `getDelimiter` returns delimiter.
     */
    getDelimiter(): number;
    /**
     * `getActorID` returns actorID.
     */
    getActorID(): string | undefined;
    /**
     * `after` returns whether the given ticket was created later.
     */
    after(other: TimeTicket): boolean;
    /**
     * `equals` returns whether the given ticket was created.
     */
    equals(other: TimeTicket): boolean;
    /**
     * `compare` returns an integer comparing two Ticket.
     *  The result will be 0 if id==other, -1 if `id < other`, and +1 if `id > other`.
     *  If the receiver or argument is nil, it would panic at runtime.
     */
    compare(other: TimeTicket): number;
}
declare class TimeTicket_2 {
    getLamport(): string;
    setLamport(value: string): TimeTicket_2;
    getDelimiter(): number;
    setDelimiter(value: number): TimeTicket_2;
    getActorId(): Uint8Array | string;
    getActorId_asU8(): Uint8Array;
    getActorId_asB64(): string;
    setActorId(value: Uint8Array | string): TimeTicket_2;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TimeTicket_2.AsObject;
    static toObject(includeInstance: boolean, msg: TimeTicket_2): TimeTicket_2.AsObject;
    static serializeBinaryToWriter(message: TimeTicket_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TimeTicket_2;
    static deserializeBinaryFromReader(message: TimeTicket_2, reader: jspb.BinaryReader): TimeTicket_2;
}
declare namespace TimeTicket_2 {
    type AsObject = {
        lamport: string;
        delimiter: number;
        actorId: Uint8Array | string;
    };
}
/**
 * `toChangePack` converts the given model to Protobuf format.
 */
declare function toChangePack(pack: ChangePack): ChangePack_2;
/**
 * `toClient` converts the given model to Protobuf format.
 */
declare function toClient<M>(id: string, presence: PresenceInfo<M>): Client_2;
/**
 * `toHexString` converts the given byte array to hex string.
 */
declare function toHexString(bytes: Uint8Array): string;
declare type ToInternalOpInfo<T extends OperationInfo> = Omit<T, 'path'> & {
    element: TimeTicket;
};
/**
 * `toUnit8Array` converts the given hex string to byte array.
 */
declare function toUint8Array(hex: string): Uint8Array;
/**
 * `Tree` is a CRDT-based tree structure that is used to represent the document
 * tree of text-based editor such as ProseMirror.
 */
export declare class Tree {
    private initialRoot?;
    private context?;
    private tree?;
    constructor(initialRoot?: ElementNode);
    /**
     * `initialize` initialize this tree with context and internal tree.
     * @internal
     */
    initialize(context: ChangeContext, tree: CRDTTree): void;
    /**
     * `getID` returns the ID of this tree.
     */
    getID(): TimeTicket;
    /**
     * `getInitialRoot` returns the root node of this tree.
     */
    buildRoot(context: ChangeContext): CRDTTreeNode;
    /**
     * `getSize` returns the size of this tree.
     */
    getSize(): number;
    /**
     * `getIndexTree` returns the index tree of this tree.
     */
    getIndexTree(): IndexTree<CRDTTreeNode>;
    /**
     * `editByPath` edits this tree with the given node and path.
     */
    editByPath(fromPath: Array<number>, toPath: Array<number>, content?: TreeNode): boolean;
    /**
     * `edit` edits this tree with the given node.
     */
    edit(fromIdx: number, toIdx: number, content?: TreeNode): boolean;
    /**
     * `split` splits this tree at the given index.
     */
    split(index: number, depth: number): boolean;
    /**
     * `toXML` returns the XML string of this tree.
     */
    toXML(): string;
    /**
     * `toJSON` returns the JSON string of this tree.
     */
    toJSON(): string;
    /**
     * `indexToPath` returns the path of the given index.
     */
    indexToPath(index: number): Array<number>;
    /**
     * eslint-disable-next-line jsdoc/require-jsdoc
     * @internal
     */
    [Symbol.iterator](): IterableIterator<TreeNode>;
}
/**
 * `TreeChange` represents the change in the tree.
 */
export declare interface TreeChange {
    actor: ActorID;
    type: TreeChangeType;
    from: number;
    to: number;
    fromPath: Array<number>;
    toPath: Array<number>;
    value?: TreeNode_2;
}
/**
 * `TreeChangeType` represents the type of change in the tree.
 */
export declare enum TreeChangeType {
    Content = "content"
}
declare type TreeEditOpInfo = {
    type: 'tree-edit';
    from: number;
    to: number;
    fromPath: Array<number>;
    toPath: Array<number>;
    value: TreeNode_2;
    path: string;
};
export declare type TreeNode = TextNode | ElementNode;
/**
 * `TreeNode` represents the JSON representation of a node in the tree.
 * It is used to serialize and deserialize the tree.
 */
declare type TreeNode_2 = {
    type: TreeNodeType;
    children?: Array<TreeNode_2>;
    value?: string;
};
declare class TreeNode_3 {
    getPos(): TreePos_2 | undefined;
    setPos(value?: TreePos_2): TreeNode_3;
    hasPos(): boolean;
    clearPos(): TreeNode_3;
    getType(): string;
    setType(value: string): TreeNode_3;
    getValue(): string;
    setValue(value: string): TreeNode_3;
    getRemovedAt(): TimeTicket_2 | undefined;
    setRemovedAt(value?: TimeTicket_2): TreeNode_3;
    hasRemovedAt(): boolean;
    clearRemovedAt(): TreeNode_3;
    getInsPrevPos(): TreePos_2 | undefined;
    setInsPrevPos(value?: TreePos_2): TreeNode_3;
    hasInsPrevPos(): boolean;
    clearInsPrevPos(): TreeNode_3;
    getDepth(): number;
    setDepth(value: number): TreeNode_3;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TreeNode_3.AsObject;
    static toObject(includeInstance: boolean, msg: TreeNode_3): TreeNode_3.AsObject;
    static serializeBinaryToWriter(message: TreeNode_3, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TreeNode_3;
    static deserializeBinaryFromReader(message: TreeNode_3, reader: jspb.BinaryReader): TreeNode_3;
}
declare namespace TreeNode_3 {
    type AsObject = {
        pos?: TreePos_2.AsObject;
        type: string;
        value: string;
        removedAt?: TimeTicket_2.AsObject;
        insPrevPos?: TreePos_2.AsObject;
        depth: number;
    };
}
/**
 * `TreeNodeForTest` represents the JSON representation of a node in the tree.
 * It is used for testing.
 */
declare type TreeNodeForTest = TreeNode_2 & {
    children?: Array<TreeNodeForTest>;
    size: number;
    isRemoved: boolean;
};
/**
 * `NoteType` is the type of a node in the tree.
 */
declare type TreeNodeType = string;
/**
 * `TreePos` is the position of a node in the tree.
 *
 * `offset` is the position of node's token. For example, if the node is an
 * element node, the offset is the index of the child node. If the node is a
 * text node, the offset is the index of the character.
 */
declare type TreePos<T extends IndexTreeNode<T>> = {
    node: T;
    offset: number;
};
declare class TreePos_2 {
    getCreatedAt(): TimeTicket_2 | undefined;
    setCreatedAt(value?: TimeTicket_2): TreePos_2;
    hasCreatedAt(): boolean;
    clearCreatedAt(): TreePos_2;
    getOffset(): number;
    setOffset(value: number): TreePos_2;
    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): TreePos_2.AsObject;
    static toObject(includeInstance: boolean, msg: TreePos_2): TreePos_2.AsObject;
    static serializeBinaryToWriter(message: TreePos_2, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): TreePos_2;
    static deserializeBinaryFromReader(message: TreePos_2, reader: jspb.BinaryReader): TreePos_2;
}
declare namespace TreePos_2 {
    type AsObject = {
        createdAt?: TimeTicket_2.AsObject;
        offset: number;
    };
}
/**
 * @internal
 */
export declare type Unsubscribe = () => void;
export declare interface ValueChange<T> {
    actor: ActorID;
    from: number;
    to: number;
    value?: T;
}
declare enum ValueType {
    VALUE_TYPE_NULL = 0,
    VALUE_TYPE_BOOLEAN = 1,
    VALUE_TYPE_INTEGER = 2,
    VALUE_TYPE_LONG = 3,
    VALUE_TYPE_DOUBLE = 4,
    VALUE_TYPE_STRING = 5,
    VALUE_TYPE_BYTES = 6,
    VALUE_TYPE_DATE = 7,
    VALUE_TYPE_JSON_OBJECT = 8,
    VALUE_TYPE_JSON_ARRAY = 9,
    VALUE_TYPE_TEXT = 10,
    VALUE_TYPE_INTEGER_CNT = 11,
    VALUE_TYPE_LONG_CNT = 12,
    VALUE_TYPE_TREE = 13
}
/**
 * `WrappedElement` is a wrapper of JSONElement that provides `getID()`.
 */
export declare type WrappedElement<T = unknown, A extends Indexable = Indexable> = Primitive | JSONObject<T> | JSONArray<T> | Text_2<A> | Counter | Tree;
/**
 * The top-level yorkie namespace with additional properties.
 *
 * In production, this will be called exactly once and the result
 * assigned to the `yorkie` global.
 *
 * e.g) `new yorkie.Client(...);`
 *
 * @public
 */
declare const yorkie: {
    Client: typeof Client;
    Document: typeof Document_2;
    Text: typeof Text_2;
    Counter: typeof Counter;
    Tree: typeof Tree;
    IntType: CounterType;
    LongType: CounterType;
};
export default yorkie;
export {};
