<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Drawing Example</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <div>
      <div>There are currently <span id="peersCount"></span> peers!</div>
      <canvas
        width="500px"
        height="500px"
        id="drawing-panel"
        style="border: 1px solid black"
      ></canvas>
      <div>peers:</div>
      <pre style="white-space: pre-wrap"><code id="peer-log"></code></pre>
      <div>document:</div>
      <pre style="white-space: pre-wrap"><code id="doc-log"></code></pre>
    </div>
    <script src="./yorkie.js"></script>
    <script>
      const drawingPanel = document.getElementById('drawing-panel');
      const docPanel = document.getElementById('doc-log');
      const peerPanel = document.getElementById('peer-log');

      function getPoint(e) {
        return {
          x: e.clientX - drawingPanel.offsetLeft + window.scrollX,
          y: e.clientY - drawingPanel.offsetTop + window.scrollY,
        };
      }

      async function main() {
        try {
          // 01. create client with RPCAddr(envoy) then activate it.
          const client = new yorkie.Client('http://localhost:8080', {
            syncLoopDuration: 0,
            reconnectStreamDelay: 1000,
          });
          await client.activate();

          // 02. create a document then attach it into the client.
          const doc = await client.attach('drawing-panel');
          let draftShape = null;
          function displayLog() {
            const peers = doc.getPeers();
            docPanel.innerText = JSON.stringify(doc.getRoot().toJS(), null, 2);
            peerPanel.innerText = JSON.stringify(peers, null, 2);
          }
          function paintCanvas() {
            // TODO Now repainting the whole thing. Only changed parts should be drawn.
            const context = drawingPanel.getContext('2d');
            context.clearRect(0, 0, 500, 500);

            const shapes = doc.getRoot().shapes;
            for (const shape of shapes) {
              context.beginPath();
              let isMoved = false;
              for (const p of shape.points) {
                if (isMoved === false) {
                  isMoved = true;
                  context.moveTo(p.x, p.y);
                } else {
                  context.lineTo(p.x, p.y);
                }
              }
              context.stroke();
            }

            const peers = doc.getPeers();
            for (const peer of peers) {
              if (peer.presence.draftShape) {
                context.beginPath();
                let isMoved = false;
                for (const p of peer.presence.draftShape.points) {
                  if (isMoved === false) {
                    isMoved = true;
                    context.moveTo(p.x, p.y);
                  } else {
                    context.lineTo(p.x, p.y);
                  }
                }
                context.stroke();
              }
            }
          }

          client.subscribe((event) => {
            console.log('client event', event);
            if (event.type === 'peers-changed') {
              const peers = doc.getPeers();
              document.getElementById('peersCount').innerHTML = peers.length;
              const peersPresence = peers.map(
                (peer) => peer.presence.draftShape,
              );
              paintCanvas();
              displayLog();
            }
          });

          doc.update((root) => {
            if (!root['shapes']) {
              root['shapes'] = [];
            }
          }, 'create points if not exists');

          doc.subscribe((event) => {
            console.log('doc event', event);
            displayLog();
            paintCanvas(doc.getRoot().shapes);
          });

          document.addEventListener('mousedown', (e) => {
            if (!window.isMouseDown) {
              window.isMouseDown = true;
              const point = getPoint(e);
              if (
                point.x < 0 ||
                point.y < 0 ||
                point.x > 500 ||
                point.y > 500
              ) {
                return;
              }

              draftShape = { points: [point] };
              doc.update(() => {
                doc.updatePresence({ draftShape });
              });
            }
          });

          document.addEventListener('mousemove', (e) => {
            if (window.isMouseDown) {
              const point = getPoint(e);
              if (
                point.x < 0 ||
                point.y < 0 ||
                point.x > 500 ||
                point.y > 500
              ) {
                return;
              }

              draftShape.points.push(point);
              doc.update(() => {
                doc.updatePresence({ draftShape });
              });
            }
          });

          document.addEventListener('mouseup', (e) => {
            if (window.isMouseDown) {
              window.isMouseDown = false;
              doc.update((root) => {
                if (draftShape) {
                  root.shapes.push(draftShape);
                  draftShape = null;
                }
                doc.updatePresence({ draftShape: null });
              });
            }
          });

          // 05. set initial value.
          paintCanvas();
          displayLog();
        } catch (e) {
          console.error(e);
        }
      }

      main();
    </script>
  </body>
</html>
