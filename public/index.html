<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Codemirror Example</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.css"
    />
    <link rel="stylesheet" href="style.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.js"></script>
  </head>
  <body>
    <div>
      <div>status: <span id="network-status"></span></div>
      <textarea id="placeholder" cols="30" rows="10"></textarea>
      <div>peers: <span id="peers-count"></span></div>
      <pre style="white-space: pre-wrap"><code id="peers-holder"></code></pre>
      <div>document:</div>
      <pre style="white-space: pre-wrap"><code id="log-holder"></code></pre>
      <div>text:</div>
      <pre
        style="white-space: pre-wrap"
      ><code id="text-log-holder"></code></pre>
    </div>
    <script src="./yorkie.js"></script>
    <script src="./util.js"></script>
    <script>
      const statusHolder = document.getElementById('network-status');
      const placeholder = document.getElementById('placeholder');
      const peersCount = document.getElementById('peers-count');
      const peersHolder = document.getElementById('peers-holder');
      const logHolder = document.getElementById('log-holder');
      const textLogHolder = document.getElementById('text-log-holder');
      const selectionMap = new Map();

      function getRandomColor() {
        const colors = ['#FECEEA', '#FEF1D2', '#A9FDD8', '#D7F8FF', '#CEC5FA'];
        const randomIndex = Math.floor(Math.random() * colors.length);
        return colors[randomIndex];
      }

      function displayLog(doc) {
        logHolder.innerText = doc.toJSON();
        textLogHolder.innerText = doc.getRoot().content.getStructureAsString();
      }

      function displayPeers(peers, myClientID) {
        const usernames = [];
        for (const { clientID, presence } of peers) {
          usernames.push(
            clientID === myClientID ? `<b>${clientID}</b>` : clientID,
          );
        }
        peersCount.textContent = peers.length;
        peersHolder.innerHTML = JSON.stringify(usernames);
      }

      function displayPeerSelection(doc, codemirror, myClientID) {
        for (const peer of doc.getPeers()) {
          const { clientID, presence } = peer;
          if (!presence.selection || clientID === myClientID) continue;
          displayRemoteSelection(
            codemirror,
            doc,
            presence.selection.from,
            presence.selection.to,
            clientID,
          );
        }
      }

      // https://github.com/codemirror/CodeMirror/pull/5619
      function replaceRangeFix(cm, text, from, to, origin) {
        const adjust = cm.listSelections().findIndex(({ anchor, head }) => {
          return (
            CodeMirror.cmpPos(anchor, head) === 0 &&
            CodeMirror.cmpPos(anchor, from) === 0
          );
        });
        cm.operation(() => {
          cm.replaceRange(text, from, to, origin);
          if (adjust > -1) {
            const range = cm.listSelections()[adjust];
            if (
              range &&
              CodeMirror.cmpPos(
                range.head,
                CodeMirror.changeEnd({ from, to, text }),
              ) === 0
            ) {
              const ranges = cm.listSelections().slice();
              ranges[adjust] = { anchor: from, head: from };
              cm.setSelections(ranges);
            }
          }
        });
      }

      function displayRemoteSelection(cm, doc, fromPos, toPos, actor) {
        if (selectionMap.has(actor)) {
          const selection = selectionMap.get(actor);
          selection.marker.clear();
        }

        const [fromIdx, toIdx] = doc
          .getRoot()
          .content.getRangeIndex(fromPos, toPos);
        const color = doc.getPeerPresence(actor).color;

        console.log(
          `%c remote selection from:${fromIdx} to:${toIdx}`,
          'color: skyblue',
        );

        if (fromIdx === toIdx) {
          const pos = cm.posFromIndex(fromIdx);
          const cursorCoords = cm.cursorCoords(pos);
          const cursorElement = document.createElement('span');
          cursorElement.style.borderLeftWidth = '2px';
          cursorElement.style.borderLeftStyle = 'solid';
          cursorElement.style.borderLeftColor = color;
          cursorElement.style.marginLeft = cursorElement.style.marginRight =
            '-1px';
          cursorElement.style.height =
            (cursorCoords.bottom - cursorCoords.top) * 0.9 + 'px';
          cursorElement.setAttribute('data-actor-id', actor);
          cursorElement.style.zIndex = 0;

          selectionMap.set(actor, {
            color: color,
            marker: cm.setBookmark(pos, {
              widget: cursorElement,
              insertLeft: true,
            }),
          });
        } else {
          const fromPos = cm.posFromIndex(Math.min(fromIdx, toIdx));
          const toPos = cm.posFromIndex(Math.max(fromIdx, toIdx));

          selectionMap.set(actor, {
            color: color,
            marker: cm.markText(fromPos, toPos, {
              css: `background: ${color}`,
              insertLeft: true,
            }),
          });
        }
      }

      async function main() {
        try {
          // 01-1. create client with RPCAddr(envoy).
          const client = new yorkie.Client('http://localhost:8080');
          // 01-2. subscribe client event.
          client.subscribe(network.statusListener(statusHolder));
          client.subscribe((event) => {
            console.log('client event', event);
          });
          // 01-3. activate client
          await client.activate();

          // 02. create a document then attach it into the client.
          const doc = await client.attach('codemirror', {
            initialPresence: {
              color: getRandomColor(),
            },
          });
          // 02-2. subscribe document event.
          doc.subscribe('peers', (event) => {
            console.log('peers event', event);
            if (event.type === 'watched' || event.type === 'unwatched') {
              displayPeers(doc.getPeers(), client.getID());
            }
          });
          doc.subscribe((event) => {
            console.log('doc event', event);
            displayLog(doc);
          });

          doc.update((root) => {
            if (!root.content) {
              root.content = new yorkie.Text();
            }
          }, 'create content if not exists');

          // 03. create an instance of codemirror.
          const codemirror = CodeMirror.fromTextArea(placeholder, {
            lineNumbers: true,
          });

          // 04. bind the document with the codemirror.

          // 04-1. document to codemirror(applying remote).
          doc.subscribe((event) => {
            if (event.type === 'snapshot') {
              codemirror.setValue(doc.getRoot().content.toString());
            }
            if (event.type === 'remote-change') {
              const { actor, message, operations, presence } = event.value;
              for (const op of operations) {
                if (op.type === 'edit') {
                  const from = op.from;
                  const to = op.to;
                  const content = op.value.content || '';

                  console.log(
                    `%c remote: ${from}-${to}: ${content}`,
                    'color: skyblue',
                  );
                  const fromIdx = codemirror.posFromIndex(from);
                  const toIdx = codemirror.posFromIndex(to);
                  replaceRangeFix(
                    codemirror,
                    content,
                    fromIdx,
                    toIdx,
                    'yorkie',
                  );
                }
              }

              const textLength = codemirror.getValue().length;
              if (
                doc.getRoot().content.length !=
                  doc.getRoot().content.toString().length ||
                (textLength != doc.getRoot().content.length && textLength != 0)
              ) {
                debugger;
              }
            }
          });
          doc.subscribe('peers', (event) => {
            if (event.type === 'unwatched') {
              const { clientID } = event.peer;
              if (selectionMap.has(clientID)) {
                const selection = selectionMap.get(clientID);
                selection.marker.clear();
              }
            }
            if (event.type === 'presence-changed') {
              const { clientID, presence } = event.peer;
              if (clientID === client.getID()) return;
              if (presence && presence.selection) {
                displayRemoteSelection(
                  codemirror,
                  doc,
                  presence.selection.from,
                  presence.selection.to,
                  clientID,
                );
              }
            }
          });

          // 04-2. codemirror to document(applying local).
          codemirror.on('beforeChange', (cm, change) => {
            if (change.origin === 'yorkie' || change.origin === 'setValue') {
              return;
            }

            const from = cm.indexFromPos(change.from);
            const to = cm.indexFromPos(change.to);
            const content = change.text.join('\n');

            doc.update((root) => {
              const updatedIndex = root.content.edit(from, to, content);
              const [fromPos, toPos] = root.content.getRangePos(
                updatedIndex.from,
                updatedIndex.to,
              );
              doc.updatePresence({
                selection: {
                  from: fromPos,
                  to: toPos,
                },
              });
            }, `update content by ${client.getID()}`);

            console.log(`%c local: ${from}-${to}: ${content}`, 'color: green');
          });
          codemirror.on('change', (cm, change) => {
            if (change.origin === 'yorkie' || change.origin === 'setValue') {
              return;
            }

            const textLength = codemirror.getValue().length;
            if (
              doc.getRoot().content.length !=
                doc.getRoot().content.toString().length ||
              (textLength != doc.getRoot().content.length && textLength != 0)
            ) {
              debugger;
            }
          });

          codemirror.on('beforeSelectionChange', (cm, change) => {
            // Fix concurrent issue.
            // NOTE: The following conditional statement ignores cursor changes
            //       that occur while applying remote changes to CodeMirror
            //       and handles only movement by keyboard and mouse.
            if (change.origin === undefined) {
              return;
            }

            const from = cm.indexFromPos(change.ranges[0].anchor);
            const to = cm.indexFromPos(change.ranges[0].head);
            doc.update((root) => {
              const [fromPos, toPos] = root.content.getRangePos(from, to);
              doc.updatePresence({
                selection: {
                  from: fromPos,
                  to: toPos,
                },
              });
            }, `update selection by ${client.getID()}`);
          });

          // 05. synchronize text of document and codemirror.
          codemirror.setValue(doc.getRoot().content.toString());
          displayPeers(doc.getPeers(), client.getID());
          displayPeerSelection(doc, codemirror, client.getID());
          displayLog(doc);
        } catch (e) {
          console.error(e);
        }
      }

      main();
    </script>
  </body>
</html>
