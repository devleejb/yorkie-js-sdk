<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Codemirror Example</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.css"
    />
    <link rel="stylesheet" href="style.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.48.4/codemirror.js"></script>
  </head>
  <body>
    <div>
      <div>status: <span id="network-status"></span></div>
      <textarea id="placeholder" cols="30" rows="10"></textarea>
      <div>peers:</div>
      <pre style="white-space: pre-wrap"><code id="peers-holder"></code></pre>
      <div>document:</div>
      <pre style="white-space: pre-wrap"><code id="log-holder"></code></pre>
      <div>text:</div>
      <pre
        style="white-space: pre-wrap"
      ><code id="text-log-holder"></code></pre>
    </div>
    <script src="./yorkie.js"></script>
    <script src="./util.js"></script>
    <script>
      const statusHolder = document.getElementById('network-status');
      const placeholder = document.getElementById('placeholder');
      const peersHolder = document.getElementById('peers-holder');
      const logHolder = document.getElementById('log-holder');
      const textLogHolder = document.getElementById('text-log-holder');
      const selectionMap = new Map();

      function getRandomColor() {
        const colors = ['#FECEEA', '#FEF1D2', '#A9FDD8', '#D7F8FF', '#CEC5FA'];
        const randomIndex = Math.floor(Math.random() * colors.length);
        return colors[randomIndex];
      }

      function displayLog(doc, codemirror) {
        logHolder.innerText = doc.toJSON();
        const textLength = codemirror.getValue().length;
        if (
          doc.getRoot().content.length !=
            doc.getRoot().content.toString().length ||
          (textLength != doc.getRoot().content.length && textLength != 0)
        ) {
          // debugger;
        }
        textLogHolder.innerText = doc.getRoot().content.getStructureAsString();
      }

      function displayPeers(peers, myClientID) {
        const usernames = [];
        for (const { clientID, presence } of peers) {
          usernames.push(
            clientID === myClientID ? `<b>${clientID}</b>` : clientID,
          );
        }
        peersHolder.innerHTML = JSON.stringify(usernames);
      }

      // https://github.com/codemirror/CodeMirror/pull/5619
      function replaceRangeFix(cm, text, from, to, origin) {
        const adjust = cm.listSelections().findIndex(({ anchor, head }) => {
          return (
            CodeMirror.cmpPos(anchor, head) === 0 &&
            CodeMirror.cmpPos(anchor, from) === 0
          );
        });
        cm.operation(() => {
          cm.replaceRange(text, from, to, origin);
          if (adjust > -1) {
            const range = cm.listSelections()[adjust];
            if (
              range &&
              CodeMirror.cmpPos(
                range.head,
                CodeMirror.changeEnd({ from, to, text }),
              ) === 0
            ) {
              const ranges = cm.listSelections().slice();
              ranges[adjust] = { anchor: from, head: from };
              cm.setSelections(ranges);
            }
          }
        });
      }

      function displayRemoteSelection(cm, doc, fromPos, toPos, actor) {
        if (selectionMap.has(actor)) {
          const selection = selectionMap.get(actor);
          selection.marker.clear();
        }

        const [fromIdx, toIdx] = doc
          .getRoot()
          .content.getRangeIndex(fromPos, toPos);
        const color = doc.getPeerPresence(actor).color;

        console.log(
          `%c remote selection from:${fromIdx} to:${toIdx}`,
          'color: skyblue',
        );

        if (fromIdx === toIdx) {
          const pos = cm.posFromIndex(fromIdx);
          const cursorCoords = cm.cursorCoords(pos);
          const cursorElement = document.createElement('span');
          cursorElement.style.borderLeftWidth = '2px';
          cursorElement.style.borderLeftStyle = 'solid';
          cursorElement.style.borderLeftColor = color;
          cursorElement.style.marginLeft = cursorElement.style.marginRight =
            '-1px';
          cursorElement.style.height =
            (cursorCoords.bottom - cursorCoords.top) * 0.9 + 'px';
          cursorElement.setAttribute('data-actor-id', actor);
          cursorElement.style.zIndex = 0;

          selectionMap.set(actor, {
            color: color,
            marker: cm.setBookmark(pos, {
              widget: cursorElement,
              insertLeft: true,
            }),
          });
        } else {
          const fromPos = cm.posFromIndex(Math.min(fromIdx, toIdx));
          const toPos = cm.posFromIndex(Math.max(fromIdx, toIdx));

          selectionMap.set(actor, {
            color: color,
            marker: cm.markText(fromPos, toPos, {
              css: `background: ${color}`,
              insertLeft: true,
            }),
          });
        }
      }

      async function main() {
        try {
          // 01-1. create client with RPCAddr(envoy).
          const client = new yorkie.Client('http://localhost:8080');
          // 01-2. subscribe client event.
          client.subscribe(network.statusListener(statusHolder));
          client.subscribe((event) => {
            console.log('client event', event);
          });
          // 01-3. activate client
          await client.activate();

          // 02. create a document then attach it into the client.
          const doc = await client.connect('codemirror', {
            initialPresence: {
              color: getRandomColor(),
            },
          });
          // 02-2. subscribe document event.
          doc.subscribe((event) => {
            console.log('doc event', event);
            displayLog(doc, codemirror);
            if (event.type === 'peers-changed') {
              displayPeers(doc.getPeers(), client.getID());
              if (event.value.type === 'unwatched') {
                const peerID = event.value.peers[0].clientID;
                if (selectionMap.has(peerID)) {
                  const selection = selectionMap.get(peerID);
                  selection.marker.clear();
                }
              }
              if (event.value.type === 'initialized') {
                for (const peer of event.value.peers) {
                  const { clientID, presence } = peer;
                  if (!presence.selection) continue;
                  displayRemoteSelection(
                    codemirror,
                    doc,
                    presence.selection.from,
                    presence.selection.to,
                    clientID,
                  );
                }
              }
            }
            if (event.type === 'snapshot') {
              // The text is replaced to snapshot and must be re-synced.
              syncText();
            }
            // 04-2. document to codemirror(applying remote).
            if (event.type === 'remote-change') {
              const changeInfos = event.value;
              for (const changeInfo of changeInfos) {
                const { actor, message, operations, presence } = changeInfo;
                // 1) handle edit operation
                for (const op of operations) {
                  if (op.type === 'edit') {
                    const from = op.from;
                    const to = op.to;
                    const content = op.value.content || '';

                    console.log(
                      `%c remote: ${from}-${to}: ${content}`,
                      'color: skyblue',
                    );
                    const fromIdx = codemirror.posFromIndex(from);
                    const toIdx = codemirror.posFromIndex(to);
                    replaceRangeFix(
                      codemirror,
                      content,
                      fromIdx,
                      toIdx,
                      'yorkie',
                    );
                  }
                }
                // 2) handle presence
                if (presence && presence.selection) {
                  displayRemoteSelection(
                    codemirror,
                    doc,
                    presence.selection.from,
                    presence.selection.to,
                    actor,
                  );
                }
              }
            }
          });

          doc.update((root) => {
            if (!root.content) {
              root.content = new yorkie.Text();
            }
          }, 'create content if not exists');

          // 03. create an instance of codemirror.
          const codemirror = CodeMirror.fromTextArea(placeholder, {
            lineNumbers: true,
          });

          // 04. bind the document with the codemirror.
          // 04-1. codemirror to document(applying local).
          codemirror.on('beforeChange', (cm, change) => {
            if (change.origin === 'yorkie' || change.origin === 'setValue') {
              return;
            }

            const from = cm.indexFromPos(change.from);
            const to = cm.indexFromPos(change.to);
            const content = change.text.join('\n');

            doc.update((root) => {
              const updatedIndex = root.content.edit(from, to, content);
              const [fromPos, toPos] = root.content.getRangePos(
                updatedIndex.from,
                updatedIndex.to,
              );
              doc.updatePresence('selection', {
                from: fromPos,
                to: toPos,
              });
            }, `update content by ${client.getID()}`);

            console.log(`%c local: ${from}-${to}: ${content}`, 'color: green');
          });
          codemirror.on('beforeSelectionChange', (cm, change) => {
            // Fix concurrent issue.
            // NOTE: The following conditional statement ignores cursor changes
            //       that occur while applying remote changes to CodeMirror
            //       and handles only movement by keyboard and mouse.
            if (change.origin === undefined) {
              return;
            }

            const from = cm.indexFromPos(change.ranges[0].anchor);
            const to = cm.indexFromPos(change.ranges[0].head);
            doc.update((root) => {
              const [fromPos, toPos] = root.content.getRangePos(from, to);
              doc.updatePresence('selection', {
                from: fromPos,
                to: toPos,
              });
            }, `update selection by ${client.getID()}`);
          });

          // 05. synchronize text of document and codemirror.
          function syncText() {
            const text = doc.getRoot().content;
            codemirror.setValue(text.toString());
          }
          syncText();

          displayLog(doc, codemirror);
        } catch (e) {
          console.error(e);
        }
      }

      main();
    </script>
  </body>
</html>
